#!/usr/bin/perl -w

use strict;
use ActivePerl::PPM::limited_inc;

use ActivePerl::PPM::Client;
use ActivePerl::PPM::Web qw(web_ua);
use ActivePerl::PPM::Logger qw(ppm_log);
use File::Path qw(mkpath rmtree);

$SIG{__WARN__} = sub { ppm_log("WARNING", $_[0]) };

(my $PROGNAME = $0) =~ s,.*[\\/],,;

my $CMD = shift || gui();
$CMD = "version" if $CMD eq "--version";

my $do_cmd = "do_$CMD";
usage("Unrecognized ppm command '$CMD'") unless defined &$do_cmd;

my $ppm = ActivePerl::PPM::Client->new;

eval {
    no strict 'refs';
    ppm_log("INFO", "$PROGNAME $CMD" . (@ARGV ? " @ARGV" : ""));
    &$do_cmd;
};
if ($@) {
    ppm_log("ERR", "$PROGNAME $CMD: $@");
    $@ =~ s/ at .*// unless $ENV{ACTIVEPERL_PPM_DEBUG};
    print STDERR "$PROGNAME $CMD failed: $@";
    exit 1;
}
else {
    exit;
}

my $USAGE;
sub usage {
    my $msg = shift;
    if ($msg) {
	$msg .= "\n" unless $msg =~ /\n$/;
	print STDERR $msg;
    }
    $USAGE ||= "<cmd> args...";
    print STDERR "Usage: $PROGNAME $USAGE\n";
    exit 1;
}

sub gui {
    usage("The graphical shell has not been implemented yet.");
}

sub do_dump {
    require Data::Dump;
    push(@ARGV, "client") unless @ARGV;
    for my $what (@ARGV) {
	if ($what eq "client") {
	    Data::Dump::dump($ppm);
	}
	elsif (grep $_ eq $what,$ppm->idirs) {
	    Data::Dump::dump($ppm->idirs($what));
	}
	elsif (grep $_ eq $what, $ppm->repos) {
	    Data::Dump::dump($ppm->repo($what));
	}
	elsif (my $pkg = $ppm->current_idirs->package($what)) {
	    Data::Dump::dump($pkg);
	}
	else {
	    warn "No idirs/repo/package called $what\n";
	}
    }
}

sub do_version {
    if (@ARGV) {
	$USAGE = "version";
	usage("The $CMD command does not take arguments.");
    }
    require ActivePerl::PPM;
    print "ppm $ActivePerl::PPM::VERSION (Beta 1)\n";
    print "Copyright (C) 2006 ActiveState Software Inc.  All rights reserved.\n";
}

sub do_help {
    if (@ARGV) {
	$USAGE = "help";
	usage("The $CMD command does not take arguments.");
    }
    system("perldoc", __FILE__);
}

sub do_idirs {
    my $current = $ppm->current_idirs_name;
    my $show_header = 1;
    if (@ARGV) {
	my $new_current;
	my $sync;
	$USAGE = "idirs [--current [<name>]] [--sync] [--no-header]";
	require Getopt::Long;
	Getopt::Long::GetOptions(
           'current:s' => \$new_current,
	   'sync' => \$sync,
           'header!' => \$show_header,
        ) || usage();
	usage() if @ARGV;
	if (defined $new_current) {
	    $ppm->current_idirs_name($new_current) if length($new_current);
	    $ppm->current_idirs->sync_db if $sync;
	    if (length($new_current)) {
		print "Current idir is now $new_current.\n";
	    }
	    else {
		print "$current\n";
	    }
	    return;
	}
	$ppm->current_idirs->sync_db if $sync;
    }
    if ($show_header) {
	print "cur name   pkg# lib\n";
	print "--- ------ ---- ------------------------------------\n";
    }
    for my $idir ($ppm->idirs) {
	my $o = $ppm->idirs($idir);
	printf "%3s %-6s %4d %s\n",
	    ($current eq $idir ? "->" : ""),
	    $idir,
	    scalar($o->packages),
	    $o->lib;
    }
}

sub do_list {
    my %opt;
    if (@ARGV) {
	$USAGE = "list [--name] [--version] [--date] [--abstract] [--author] [--ppd] [--files] [--size]";
	require Getopt::Long;
	Getopt::Long::GetOptions(\%opt,
           'id',
           'name',
           'version',
           'date',
           'abstract',
           'author',
	   'files',
           'size',
           'ppd',
        ) || usage();
	usage() if @ARGV;
    }
    else {
	$opt{version}++;
        $opt{date}++;
	$opt{files}++;
	$opt{size}++;
    }
    $opt{name}++;

    my $idir = $ppm->current_idirs;
    if (keys %opt == 1) {
	# just list the names
	for my $pkg ($idir->packages) {
	    print "$pkg\n";
	}
    }
    else {
	my @fields;
	push(@fields, "name");
	push(@fields, "version") if $opt{version};
	push(@fields, "release_date") if $opt{date};
	push(@fields, "abstract") if $opt{abstract};
	push(@fields, "author") if $opt{author};
	push(@fields, "ppd_uri") if $opt{ppd};
	require ActiveState::Table;
	my $tab = ActiveState::Table->new;
	$tab->add_field($_) for @fields;
	$tab->add_field("files") if $opt{files};
	$tab->add_field("size") if $opt{size};
	for my $pkg ($idir->packages(@fields)) {
	    my %row = map {$_ => shift(@$pkg)} @fields;
	    if ($row{release_date}) {
		$row{release_date} =~ s/T.*//;  # drop time
	    }
	    if ($opt{files} || $opt{size}) {
		my @files = $idir->package_files($row{name});
		$row{files} = @files if $opt{files};
		$row{size} = do {
		    require ActiveState::DiskUsage;
		    require ActiveState::Bytes;
		    my $size = 0;
		    $size += ActiveState::DiskUsage::du($_) for @files;
		    $size = ActiveState::Bytes::bytes_format($size);
		} if $opt{size};
	    }
	    $tab->add_row(\%row);
	}
	print $tab->as_box(null => "", show_trailer => 0);
    }
}

sub do_files {
    $USAGE = "files <pkg>";
    usage() unless @ARGV == 1;
    print "$_\n" for $ppm->current_idirs->package_files($ARGV[0]);
}

sub do_verify {
    my %opt;
    if (@ARGV) {
	$USAGE = "verify [--verbose] [<package>]";
	require Getopt::Long;
	Getopt::Long::GetOptions(\%opt,
           'verbose',
        ) || usage();
	$opt{package} = shift(@ARGV) if @ARGV;
	usage() if @ARGV;
    }
    my $idir = $ppm->current_idirs;
    my %status = $idir->verify(%opt);
    for my $v (qw(verified missing modified)) {
	next if $v ne "verified" && !$status{$v};
	my $s = $status{$v} == 1 ? "" : "s";
	print "$status{$v} file$s $v.\n";
    }
}

sub uri_hide_passwd {
    my $url = shift;
    return $url unless $url =~ /\@/;
    $url = URI->new($url);
    if (my $ui = $url->userinfo) {
	if ($ui =~ s/:.*/:***/) {
	    $url->userinfo($ui);
	}
    }
    return $url->as_string;
}

sub do_repo {
    my $cmd = shift(@ARGV) || "list";
    if ($cmd eq "list") {
	$USAGE = "repo list";
	usage() if @ARGV;
	for my $repo_id ($ppm->repos) {
	    my $repo = $ppm->repo($repo_id);
	    my $status = $repo->{enabled} ? "" : "(OFF) ";
	    print "[$repo_id] $status$repo->{name} <" . uri_hide_passwd($repo->{packlist_uri}) . ">\n";
	}
    }
    elsif ($cmd eq "search") {
	do_search();
    }
    elsif ($cmd eq "sync") {
	$USAGE = "repo sync [--force]";
	my $force;
	if (@ARGV) {
	    require Getopt::Long;
	    Getopt::Long::GetOptions(
	        force => \$force,
            ) || usage();
	    usage() if @ARGV;
	}
	$ppm->repo_sync(force => $force);
    }
    elsif ($cmd eq "on" || $cmd eq "off" || $cmd eq "delete" || $cmd eq "describe") {
	$USAGE = "repo $cmd <num>";
	usage() if @ARGV != 1;
	my $repo = $ppm->repo($ARGV[0]);
	die "No such repo; 'ppm repo list' will print what's available" unless $repo;
	if ($cmd eq "delete") {
	    $ppm->repo_delete($ARGV[0]);
	}
	elsif ($cmd eq "describe") {
	    require ActiveState::Duration;
	    print "Id: $repo->{id}\n";
	    print "Name: $repo->{name}\n";
	    print "URL: " . uri_hide_passwd($repo->{packlist_uri}) . "\n";
	    print "Prio: $repo->{prio}\n";
	    print "Enabled: ", ($repo->{enabled} ? "yes" : "no"), "\n";
	    if (my $last_status = $repo->{packlist_last_status_code}) {
		print "Last-Status: $last_status " . HTTP::Status::status_message($last_status) . "\n";
	    }
	    else {
		print "Last-Status: - (never accessed)\n";
	    }
	    if (my $last_access = $repo->{packlist_last_access}) {
		print "Last-Access: ", ActiveState::Duration::ago_eng(time - $last_access), "\n";
	    }
	    if (my $fresh_until = $repo->{packlist_fresh_until}) {
		my $refresh_in = $fresh_until - time;
		if ($refresh_in >= 0) {
		    print "Refresh-In: ", ActiveState::Duration::dur_format_eng($refresh_in), "\n";
		}
		else {
		    print "Refresh-In: overdue\n";
		}
	    }
	    if (my $lastmod = $repo->{packlist_lastmod}) {
		require HTTP::Date;
		print "Last-Modified: ", ActiveState::Duration::ago_eng(time - HTTP::Date::str2time($lastmod)), "\n";
	    }
	}
	else {
	    $ppm->repo_enable($ARGV[0], $cmd eq "on");
	}
    }
    elsif ($cmd eq "add") {
	$USAGE = "repo add <url> [<name>] [--username <user> [--password <password>]]";
	my $user;
	my $pass;
	require Getopt::Long;
	Getopt::Long::GetOptions(
	    'username=s' => \$user,
            'password=s' => \$pass,
        ) || usage();
	my $url = shift(@ARGV) || usage();
	my $name;
	if (@ARGV) {
	    $name = shift(@ARGV);
	    usage() if @ARGV;
	    if ($url !~ /^[a-z][+\w]+:/ && $name =~ /^[a-z][+\w]+:/) {
		# ppm3 had the arguments reversed, so try that
		($url, $name) = ($name, $url);
	    }
	}
	else {
	    $name = eval { URI->new($url)->host } || $url;
	}
	unless ($url =~ /^[a-z][+\w]+:/) {
	    if (-d $url) {
		require URI::file;
		$url = URI::file->new_abs($url);
	    }
	    else {
		die "The repository URL must be absolute or a local directory";
	    }
	}
	if ($user) {
	    $user .= ":$pass" if defined $pass;
	    $url = URI->new($url);
	    $url->userinfo($user);
	    $url = $url->as_string;
	}
	else {
	    usage() if defined $pass;
	}
	my $id = $ppm->repo_add(name => $name, packlist_uri => $url);
	print "Repo $id added.\n";
    }
    elsif ($cmd =~ /^\d+$/) {
	@ARGV = ("describe") unless @ARGV;
	if ($ARGV[0] =~ /^\d+$/) {
	    # avoids infinite recursion
	    $USAGE = "repo <num> <cmd> ...";
	    usage();
	}
	splice(@ARGV, 1, 0, $cmd);
	do_repo();
    }
    else {
	$USAGE = "repo <cmd> <args>";
	usage("The repo command '$cmd' isn't recognized; try one of list, describe, add, delete, on, off");
    }
}

sub do_search {
    $USAGE = "search <pattern>";
    usage() unless @ARGV == 1;
    my $pattern = shift(@ARGV);
    $pattern =~ s/\*/%/g;  # glob to SQL LIKE
    $pattern =~ s/\?/_/g;  # glob to SQL LIKE
    $pattern = "%$pattern%" unless $pattern =~ /[%_]/;

    my @res = $ppm->search($pattern);
    if (@res) {
	print "$_\n" for @res;
    }
    else {
	print "no packages found\n";
    }
}

sub do_install {
    $USAGE = "install [--force] <module> | <url> | <file>";
    my $force;
    require Getopt::Long;
    Getopt::Long::GetOptions(
        force => \$force,
     ) || usage();
    usage() unless @ARGV == 1;
    my $feature = shift(@ARGV);
    if ($feature =~ m,^[a-z][+\w]+:[^:],) {
	# looks like an absolute URL
	_install_uri($feature);
    }
    elsif ($feature =~ /\.ppd$/) {
	require URI::file;
	_install_uri(URI::file->new_abs($feature));
    }
    else {
	# seach for feature in repos
	_install_repo($ppm->packages_missing_for($feature, 0, force => $force));
    }
}

sub do_upgrade {
    $USAGE = "upgrade <module>";
    usage() unless @ARGV == 1;
    my $feature = shift(@ARGV);
    _install_repo($ppm->packages_missing_for($feature, undef));
}

sub _install_uri {
    my $uri = shift;
    my $res = web_ua->get($uri);
    unless ($res->is_success) {
	die $res->status_line;
    }
    require ActivePerl::PPM::PPD;
    my $cref = $res->decoded_content(ref => 1);
    my $pkg = ActivePerl::PPM::Package->new_ppd($$cref);
    unless ($pkg) {
	die "No PPD found at $uri";
    }
    if (my $codebase = $pkg->{codebase}) {
	# make it absolute
	$pkg->{codebase} = URI->new_abs($codebase, $res->base)->rel($uri)->as_string;
	$pkg->{ppd_uri} = $uri;
	$pkg->{ppd_etag} = $res->header("ETag");
	$pkg->{ppd_lastmod} = $res->header("Last-Modified");
    }
    else {
	die "The PPD does not provide code to install for this platform";
    }
    # XXX follow dependencies with the "directory" of $pkg $uri as the
    # first repo to look for additional packages.  This only works for
    # package features.

    _install($pkg);
}

sub _install_repo {
    _install(map $ppm->package_set_abs_ppd_uri($_), @_);
}

sub _install {
    unless (@_) {
	print "Nothing to install\n";
	return;
    }

    $| = 1;
    my $verbose = 0;
    my $ua = web_ua();

    my $tmpdir = do { require File::Temp; File::Temp::tempdir() };
    eval {
	# determine codebase_file
	for my $pkg (@_) {
	    my $name = $pkg->name_version;
	    my $codebase = $pkg->{codebase};
	    die "No codebase for $name" unless $codebase;
	    $codebase = URI->new_abs($codebase, $pkg->{ppd_uri});

	    if ($codebase =~ /\.(tgz|tar\.gz)$/) {
		$pkg->{codebase_type} = "tgz";
	    }
	    die "Don't know how to unpack $codebase" unless $pkg->{codebase_type};

	    if ($codebase->scheme eq 'file') {
		$pkg->{codebase_file} = $codebase->file;
		unless (-f $pkg->{codebase_file}) {
		    die "No file at $pkg->{codebase_file}";
		}
	    }
	    else {
		print "Downloading $name...";
		my $save = $pkg->{codebase_file} = "$tmpdir/$name.$pkg->{codebase_type}";
		#print "\n    $codebase ==> $save...";
		my $res = $ua->get($codebase, ":content_file" => $save);
		die $res->status_line unless $res->is_success;
		if (my $len = $res->content_length) {
		    my $save_len = -s $save;
		    if ($save_len != $len) {
			die "Aborted download ($len bytes expected, got $save_len).\n";
		    }
		}
		# XXX An MD5 checksum for the tarball would be a good thing
		print "done\n";
	    }
	}

	# unpack
	for my $pkg (@_) {
	    my $pname = $pkg->name_version;
	    print "Unpacking $pname...";
	    my $codebase_file = $pkg->{codebase_file};
	    if ($pkg->{codebase_type} eq "tgz") {
		require Archive::Tar;
		require ExtUtils::MakeMaker;
		require ActiveState::ModInfo;
		ppm_log("DEBUG", "Unpacking $codebase_file");
		my $tar = Archive::Tar->new($codebase_file, 1);
		for my $file ($tar->get_files) {
		    next unless $file->is_file;  # don't extract links and other crap
		    my $fname = $file->name;
		    next if $fname =~ m,/\.exists$,;       # don't think these are needed
		    next if $fname =~ m,/html/(bin|site/lib)/,;  # will always regenerate these
		    my $extract = $fname;
		    next unless $extract =~ s,^blib/,$pname/,;
		    $extract = "$tmpdir/$extract";
		    $tar->extract_file($fname, $extract)
			|| die "Can't extract to $extract";
		    if ($fname =~ /\.pm$/) {
			my $mod = $fname;
			if ($mod =~ s,^blib/(?:lib|arch)/,,) {
			    $mod = ActiveState::ModInfo::fname2mod($mod);
			    $mod .= "::" unless $mod =~ /::/;
			    $pkg->{provide}{$mod} = MM->parse_version($extract) || 0;
			}

		    }
		}
		$pkg->{blib} = "$tmpdir/$pname";
	    }
	    else {
		die "Don't know how to unpack $pkg->{codebase_type} files";
	    }
	    print "done\n";
	}

	# relocate
	if ($^O ne "MSWin32") {
	    require ActiveState::RelocateTree;
	    my $ppm_sponge = ActiveState::RelocateTree::spongedir('ppm');
	    my $prefix = do { require Config; $Config::Config{prefix} };
	    for my $pkg (@_) {
		print "Relocating ", $pkg->name_version, "...";
		ActiveState::RelocateTree::relocate (
		    to      => $pkg->{blib},
		    inplace => 1,
	            search  => $ppm_sponge,
	            replace => $prefix,
		);
		print "done\n";
	    }
	}

	# XXX regenerate HTML

	# install
	print "Installing...";
	if (my $summary = $ppm->current_idirs->install(@_)) {
	    print "done\n";
	    for my $what (sort keys %$summary) {
		my $n = $summary->{$what} || 0;
		printf "%4d file%s %s\n", $n, ($n == 1 ? "" : "s"), $what;
	    }
	    # XXX post install scripts
	}
	else {
	    print "\n";
	    die;
	}

	# XXX run install scripts
    };
    my $err = $@;
    rmtree($tmpdir, $verbose);
    die $err if $err;
}

sub do_remove {
    $USAGE = "remove <package> ...";
    usage() unless @ARGV;

    my $idirs = $ppm->current_idirs;
    my $removed_count = 0;
    for my $pkg (@ARGV) {
	print "$pkg: ";
	eval {
	    $idirs->uninstall($pkg);
	};
	if ($@ =~ /^Package \Q$pkg\E isn't installed/) {
	    print "not installed\n";
	}
	elsif ($@) {
	    $@ =~ s/ at .*// unless $ENV{ACTIVEPERL_PPM_DEBUG};
	    print $@;
	}
	else {
	    print "uninstalled\n";
	    $removed_count++;
	}
    }
    die "No packages uninstalled" unless $removed_count;
}

BEGIN {
    # aliases for PPM3 compatibility (mostly)
    *do_query = \&do_list;
    *do_update = \&do_upgrade;
    *do_uninstall = \&do_remove;
    *do_rep = \&do_repo;
}

__END__

=head1 NAME

ppm - Perl Package Manager, version 4

=head1 SYNOPSIS

Invoke the graphical shell (not implemented yet):

    ppm

Install, upgrade and remove packages from the current install area:

    ppm install [--force] <pkg>
    ppm install [--force] <module>
    ppm install [--force] <url>
    ppm install [--force] <file>
    ppm upgrade <pkg>
    ppm upgrade <module>
    ppm remove <pkg>

Manage and search install areas:

    ppm idirs [--current <name>] [--sync] [--no-header]
    ppm list [--name] [--version] [--abstract] ...
    ppm files <pkg>
    ppm verify [<pkg>]

Manage and search repositories:

    ppm repo list
    ppm repo sync [--force]
    ppm repo on <num>
    ppm repo off <num>
    ppm repo describe <num>
    ppm repo add <url> [<name>] [--username <user> [--password <passwd>]]
    ppm search <pattern>

Obtain version and copyright information about this program:

    ppm --version
    ppm version

=head1 DESCRIPTION

The C<ppm> program is the Package Manager for ActivePerl.  It
simplifies the task of locating, installing, upgrading and removing
Perl packages.

=head1 WHAT'S NEW IN VERSION 4

PPM version 4 is a complete rewrite.  The main changes since ppm version 3 are:

=over

=item *

The command line shell has been replaced with a graphical shell (not implemented yet, but will be in Beta 2).

=item *

PPM can now manage different installation areas (idirs).

=item *

No more precious packages.  PPM can upgrade itself as well other bundled and core modules.

=item *

Installation of packages and its dependencies happens as an atomic transaction.

=item *

PPM tracks what files it has installed and can notice if files has
been modified or deleted.  The command 'ppm verify' will report on mismatches.

=item *

State kept in local SQLite databases.  All repository state is kept
local which makes search much faster.

=item *

PPM will pick up and manage packages installed by other means;
manually or by using the CPAN shell.

=item *

No more SOAP

=item *

Underlying modules moved to the C<ActivePerl::PPM::> namespace.

=back

=head1 SEE ALSO

L<activeperl>

=head1 COPYRIGHT

Copyright (C) 2006 ActiveState Software Inc.  All rights reserved.

=cut
