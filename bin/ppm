#!/usr/bin/perl -w

use strict;
use ActivePerl::PPM::limited_inc;

use ActivePerl::PPM::Client;
use ActivePerl::PPM::Web qw(web_ua);
use ActivePerl::PPM::Logger qw(ppm_log);

$SIG{__WARN__} = sub { ppm_log("WARNING", $_[0]) };

(my $PROGNAME = $0) =~ s,.*[\\/],,;

my $CMD = shift || 'shell';
$CMD = "version" if $CMD eq "--version";

my $BOX_CHARS;
if ($ENV{ACTIVEPERL_PPM_BOX_CHARS}) {
    $BOX_CHARS = $ENV{ACTIVEPERL_PPM_BOX_CHARS};
}
elsif ($^O eq "MSWin32") {
    $BOX_CHARS = "dos";
}
elsif (($ENV{LC_ALL} || $ENV{LC_CTYPE} || $ENV{LANG} || "") =~ /\bUTF-8\b/)  {
    $BOX_CHARS = "unicode";
}

binmode(STDOUT, ":utf8") if ($BOX_CHARS || "") eq "unicode";

my $do_cmd = "do_$CMD";
unless (defined &$do_cmd) {
    require Text::Abbrev;
    my @cmds;
    for my $name (keys %main::) {
	push(@cmds, $name) if $name =~ s/^do_//;
    }
    my $abbrev = Text::Abbrev::abbrev(@cmds);
    if (my $cmd = $abbrev->{$CMD}) {
	$do_cmd = "do_$cmd";
    }
    else {
	@cmds = sort @cmds;
	require Text::Wrap;
	my $last = pop(@cmds);
	usage(Text::Wrap::wrap("", "  ",
                  "Unrecognized ppm command '$CMD'; try one of " .
                  join(", or ", join(", ", @cmds), $last)
	      )
	);
    }
}

my $ppm = ActivePerl::PPM::Client->new;

eval {
    no strict 'refs';
    ppm_log("INFO", "$PROGNAME $CMD" . (@ARGV ? " @ARGV" : ""));
    &$do_cmd;
};
if ($@) {
    ppm_log("ERR", "$PROGNAME $CMD: $@");
    $@ =~ s/ at .*// unless $ENV{ACTIVEPERL_PPM_DEBUG};
    $@ =~ s/ _at / at /g; # escape for when you really want "at" in the message
    print STDERR "$PROGNAME $CMD failed: $@";
    exit 1;
}
else {
    exit;
}

my $USAGE;
sub usage {
    my $msg = shift;
    if ($msg) {
	$msg .= "\n" unless $msg =~ /\n$/;
	print STDERR $msg;
    }
    $USAGE ||= "<cmd> <arg>...";
    print STDERR "Usage:\t$PROGNAME $USAGE\n";
    print STDERR "\tRun '$PROGNAME help" . ($USAGE =~ /^(\w+)/ ? " $1" : "") . "' to learn more.\n";
    exit 1;
}

sub do_shell {
    require ActivePerl::PPM::Shell;
}

sub do_dump {
    require Data::Dump;
    push(@ARGV, "client") unless @ARGV;
    for my $what (@ARGV) {
	if ($what eq "client") {
	    Data::Dump::dump($ppm);
	}
	elsif (grep $_ eq $what,$ppm->area) {
	    Data::Dump::dump($ppm->area($what));
	}
	elsif (grep $_ eq $what, $ppm->repos) {
	    Data::Dump::dump($ppm->repo($what));
	}
	else {
	    warn "No area/repo called $what\n";
	}
    }
}

sub do_version {
    if (@ARGV) {
	$USAGE = "version";
	usage("The $CMD command does not take arguments.");
    }
    require ActivePerl::PPM;
    print "ppm $ActivePerl::PPM::VERSION (Beta 1)\n";
    print "Copyright (C) 2006 ActiveState Software Inc.  All rights reserved.\n";
}

sub do_help {
    if (@ARGV > 1) {
	$USAGE = "help [<subcommand>]";
	usage();
    }
    my $pod2text = qq("$^X" -MPod::Text -e "Pod::Text->new->parse_from_filehandle");
    open(my $fh, "<", __FILE__) || die "Can't open " . __FILE__ . ": $!";
    if (@ARGV) {
	my $cmd = shift(@ARGV);
	my $foundit;
	while (<$fh>) {
	    if (/^=item B<ppm \Q$cmd\E\b/o) {
		$foundit++;
		last;
	    }
	}
	if ($foundit) {
	    open(my $out, "| $pod2text");
	    print $out "=over\n\n";
	    print $out $_;
	    my $over_depth = 0;
	    while (<$fh>) {
		last if /^=item B<ppm (?!\Q$cmd\E\b)/o;
		if (/^=back\b/) {
		    last if $over_depth == 0;
		    $over_depth--;
		}
		elsif (/^=over\b/) {
		    $over_depth++;
		}
		print $out $_;
	    }
	    print $out "\n\n=back\n";
	    close($out);
	}
	else {
	    print "Sorry, no help for '$cmd'\n";
	}
    }
    else {
	use ActivePerl::PPM;
	my $pager = $ENV{PAGER} || "more";
	open(my $out, qq(| $pod2text | $pager));
	while (<$fh>) {
	    s/version \d+\S*/version $ActivePerl::PPM::VERSION/ if /^ppm -/;
	    print $out $_;
	}
	close($out);
    }
}

sub do_area {
    my $cmd = shift(@ARGV) || "list";
    if ($cmd eq "list") {
	$USAGE = "area list [--csv [ <sep> ]] [--no-header]";
	my $show_header = 1;
	my $csv;
	if (@ARGV) {
	    require Getopt::Long;
	    Getopt::Long::GetOptions(
	        'header!' => \$show_header,
                'csv:s' => \$csv,
            ) || usage();
	    usage() if @ARGV;
	}
	require ActiveState::Table;
	my $tab = ActiveState::Table->new;
	$tab->add_field("name");
	$tab->add_field("pkgs");
	$tab->add_field("lib");
	my $default = $ppm->default_install_area;
	for my $area ($ppm->areas) {
	    my $o = $ppm->area($area);
	    my $name = $area;
	    $name = "$name*" if defined($default) && $name eq $default;
	    $name = "($name)" if $o->readonly;
	    $tab->add_row({
	        name => $name,
                pkgs => scalar($o->packages),
                lib => $o->lib,
            });
	}
	if (defined($csv)) {
	    $csv = "," if $csv eq "";
	    print $tab->as_csv(null => "", field_separator => $csv, show_header => $show_header);
	}
	else {
	    print $tab->as_box(null => "", show_header => $show_header, show_trailer => 0, align => {pkgs => "right"}, box_chars => $BOX_CHARS);
	}
    }
    elsif ($cmd eq "sync") {
	$USAGE = "area sync [<area>...]";
	for my $area (map $ppm->area($_), @ARGV ? @ARGV : $ppm->areas) {
	    $area->sync_db;
	}
    }
    else {
	$USAGE = "area <cmd> <args>";
	usage("The area command '$cmd' isn't recognized; try one of list, sync");
    }
}

sub do_list {
    my %opt;
    my $area_name;
    if (@ARGV) {
	$USAGE = "list [<area>] [--name] [--version] [--date] ... [--matching <pattern>] [--csv]";
	require Getopt::Long;
	Getopt::Long::GetOptions(\%opt,
           'name',
           'version',
           'date',
           'abstract',
           'author',
           'area',
	   'files',
           'size',
           'ppd',
	   'matching=s',
	   'header!',
           'csv:s',
        ) || usage();
	$area_name = shift(@ARGV) if @ARGV;
	usage() if @ARGV;
    }
    my $matching = delete $opt{matching};
    my $matching_re = glob2re($matching) if defined($matching);
    $matching = (defined $matching) ? " matching '$matching'" : "";
    my $show_header = delete $opt{header};
    $show_header = 1 unless defined $show_header;
    my $csv = delete $opt{csv};

    unless (%opt) {
	# fields to show by default
	$opt{version}++;
	$opt{files}++;
	$opt{size}++;
	if ($area_name) {
	    $opt{date}++;
	}
	else {
	    $opt{area}++;
	}
    }
    $opt{name}++;

    my @areas = ($area_name ? ($area_name) : $ppm->areas);
    my $in = $area_name ? " in '$area_name' area" : "";

    if (keys %opt == 1) {
	# just list the names
	my @pkgs = map $_->packages, map $ppm->area($_), @areas;
	@pkgs = grep $_ =~ $matching_re, @pkgs if $matching_re;
	goto NO_PKG_INSTALLED unless @pkgs;
	print "$_\n" for sort @pkgs;
    }
    else {
	my @fields;
	push(@fields, "name");
	push(@fields, "version") if $opt{version};
	push(@fields, "release_date") if $opt{date};
	push(@fields, "abstract") if $opt{abstract};
	push(@fields, "author") if $opt{author};
	push(@fields, "ppd_uri") if $opt{ppd};
	require ActiveState::Table;
	my $tab = ActiveState::Table->new;
	$tab->add_field($_) for @fields;
	$tab->add_field("area") if $opt{area};
	$tab->add_field("files") if $opt{files};
	$tab->add_field("size") if $opt{size};

	for my $area (map $ppm->area($_), @areas) {
	    for my $pkg ($area->packages(@fields)) {
		my %row = map {$_ => shift(@$pkg)} @fields;
		next if $matching_re && $row{name} !~ $matching_re;
		if ($row{release_date}) {
		    $row{release_date} =~ s/[T ].*//;  # drop time
		}
		if ($opt{files} || $opt{size}) {
		    my @files = $area->package_files($row{name});
		    $row{files} = @files if $opt{files};
		    $row{size} = do {
			require ActiveState::DiskUsage;
			my $size = 0;
			$size += ActiveState::DiskUsage::du($_) for @files;
			$size = sprintf "%.0f KB", $size / 1024 unless defined($csv);
			$size;
		    } if $opt{size};
		}
		$row{area} = $area->name if $opt{area};
		$tab->add_row(\%row);
	    }
	}
	$tab->sort(sub ($$) { my($a, $b) = @_; $a->[0] cmp $b->[0]})
	    if @areas > 1 && $tab->can("sort");

	if (defined $csv) {
	    $csv = "," if $csv eq "";
	    print $tab->as_csv(null => "", field_separator => $csv, show_header => $show_header);
	}
	elsif (my $rows = $tab->rows) {
	    print $tab->as_box(null => "", show_trailer => 0, show_header => $show_header, align => {files => "right", size => "right"}, box_chars => $BOX_CHARS);
	    if (1) {
		my $s = ($rows == 1) ? "" : "s";
		print " ($rows package$s installed$in$matching)\n";
	    }
	}
	else {
	NO_PKG_INSTALLED:
	    print STDERR "*** no packages installed$in$matching ***\n";
	}
    }
}

sub glob2re {
    my $glob = shift;
    $glob = "*$glob*" unless $glob =~ /[*?]/;
    my $re = quotemeta($glob);
    $re =~ s/\\\?/./g;
    $re =~ s/\\\*/.*/g;
    $re = "^$re\\z";
    $re =~ s/^\^\.\*//;
    $re =~ s/\.\*\\z\z//;
    return "(?i:$re)";
}

sub do_query {
    $USAGE = "query <pattern>";
    usage() unless @ARGV == 1;
    @ARGV = ("--matching", @ARGV, "--name", "--version", "--abstract", "--area");
    return do_list();
}

sub do_files {
    $USAGE = "files <pkg>";
    usage() unless @ARGV == 1;
    my $pkg = shift(@ARGV);
    my $foundit;
    for my $area (map $ppm->area($_), $ppm->areas) {
	next unless defined($area->package_id($pkg));
	$foundit++;
	print "$_\n" for $area->package_files($pkg);
    }
    not_installed($pkg) unless $foundit;
}

sub not_installed {
    my $pkg = shift;
    die "Package '$pkg' is not installed";
}

sub do_verify {
    my %opt;
    if (@ARGV) {
	$USAGE = "verify [--verbose] [<package>]";
	require Getopt::Long;
	Getopt::Long::GetOptions(\%opt,
           'verbose',
        ) || usage();
	$opt{package} = shift(@ARGV) if @ARGV;
	usage() if @ARGV;
    }
    my @areas = map $ppm->area($_), $ppm->areas;
    if ($opt{package}) {
	@areas = grep $_->package_id($opt{package}), @areas;
	not_installed($opt{package}) unless @areas;
    }
    my %status;
    for my $area (@areas) {
	my %s = $area->verify(%opt);
	while (my($k,$v) = each %s) {
	    $status{$k} += $v;
	}
    }
    for my $v (qw(verified missing modified)) {
	next if $v ne "verified" && !$status{$v};
	my $s = $status{$v} == 1 ? "" : "s";
	print "$status{$v} file$s $v.\n";
    }
}

sub uri_hide_passwd {
    my $url = shift;
    return $url unless $url =~ /\@/;
    $url = URI->new($url);
    if (my $ui = $url->userinfo) {
	if ($ui =~ s/:.*/:***/) {
	    $url->userinfo($ui);
	}
    }
    return $url->as_string;
}

sub do_repo {
    my $cmd = shift(@ARGV) || "list";
    if ($cmd eq "list") {
	$USAGE = "repo list [--csv [ <sep> ]] [--no-header]";
	my $show_header = 1;
	my $csv;
	if (@ARGV) {
	    require Getopt::Long;
	    Getopt::Long::GetOptions(
	        'header!' => \$show_header,
                'csv:s' => \$csv,
            ) || usage();
	    usage() if @ARGV;
	}
	require ActiveState::Table;
	my $tab = ActiveState::Table->new;
	$tab->add_field("id");
	$tab->add_field("on");
	$tab->add_field("name");
	my $count = 0;
	for my $repo_id ($ppm->repos) {
	    my $repo = $ppm->repo($repo_id);
	    $tab->add_row({
	        id => $repo_id,
                on => $repo->{enabled} ? "yes" : "",
		name => $repo->{name},
            });
	    $count++ if $repo->{enabled};
	}
	if (defined($csv)) {
	    $csv = "," if $csv eq "";
	    print $tab->as_csv(null => "", field_separator => $csv, show_header => $show_header);
	}
	else {
	    print $tab->as_box(null => "", show_trailer => 0, show_header => $show_header, align => {id => "right"}, box_chars => $BOX_CHARS);
	    my $s = ($count == 1) ? "y" : "ies";
	    $count ||= "no";
	    print " ($count enabled repositor$s)\n";
	}
    }
    elsif ($cmd eq "search") {
	do_search();
    }
    elsif ($cmd eq "sync") {
	$USAGE = "repo sync [--force]";
	my $force;
	if (@ARGV) {
	    require Getopt::Long;
	    Getopt::Long::GetOptions(
	        force => \$force,
            ) || usage();
	    usage() if @ARGV;
	}
	$ppm->repo_sync(force => $force);
    }
    elsif ($cmd eq "on" || $cmd eq "off" || $cmd eq "delete" || $cmd eq "describe") {
	$USAGE = "repo $cmd <num>";
	usage() if @ARGV != 1;
	my $repo = $ppm->repo($ARGV[0]);
	die "No such repo; 'ppm repo list' will print what's available" unless $repo;
	if ($cmd eq "delete") {
	    $ppm->repo_delete($ARGV[0]);
	}
	elsif ($cmd eq "describe") {
	    require ActiveState::Duration;
	    print "Id: $repo->{id}\n";
	    print "Name: $repo->{name}\n";
	    print "URL: " . uri_hide_passwd($repo->{packlist_uri}) . "\n";
	    print "Prio: $repo->{prio}\n";
	    print "Enabled: ", ($repo->{enabled} ? "yes" : "no"), "\n";
	    if (my $last_status = $repo->{packlist_last_status_code}) {
		print "Last-Status: $last_status " . HTTP::Status::status_message($last_status) . "\n";
	    }
	    else {
		print "Last-Status: - (never accessed)\n";
	    }
	    if (my $last_access = $repo->{packlist_last_access}) {
		print "Last-Access: ", ActiveState::Duration::ago_eng(time - $last_access), "\n";
	    }
	    if (my $fresh_until = $repo->{packlist_fresh_until}) {
		my $refresh_in = $fresh_until - time;
		if ($refresh_in >= 0) {
		    print "Refresh-In: ", ActiveState::Duration::dur_format_eng($refresh_in), "\n";
		}
		else {
		    print "Refresh-In: overdue\n";
		}
	    }
	    if (my $lastmod = $repo->{packlist_lastmod}) {
		require HTTP::Date;
		print "Last-Modified: ", ActiveState::Duration::ago_eng(time - HTTP::Date::str2time($lastmod)), "\n";
	    }
	}
	else {
	    $ppm->repo_enable($ARGV[0], $cmd eq "on");
	}
    }
    elsif ($cmd eq "add") {
	$USAGE = "repo add <url> [<name>] [--username <user> [--password <password>]]";
	my $user;
	my $pass;
	require Getopt::Long;
	Getopt::Long::GetOptions(
	    'username=s' => \$user,
            'password=s' => \$pass,
        ) || usage();
	my $url = shift(@ARGV) || usage();
	my $name;
	if (@ARGV) {
	    $name = shift(@ARGV);
	    usage() if @ARGV;
	    if ($url !~ /^[a-z][+\w]+:/ && $name =~ /^[a-z][+\w]+:/) {
		# ppm3 had the arguments reversed, so try that
		($url, $name) = ($name, $url);
	    }
	}
	else {
	    $name = eval { URI->new($url)->host } || $url;
	}
	unless ($url =~ /^[a-z][+\w]+:/) {
	    if (-d $url) {
		require URI::file;
		$url = URI::file->new_abs($url);
	    }
	    elsif (eval {require PPM::Repositories} and
		   my $repo = $PPM::Repositories::Repositories{$url})
	    {
		$name ||= $url;
		$url = $repo->{location};
	    }
	    else {
		die "The repository URL must be absolute or a local directory";
	    }
	}
	if ($user) {
	    $user .= ":$pass" if defined $pass;
	    $url = URI->new($url);
	    $url->userinfo($user);
	    $url = $url->as_string;
	}
	else {
	    usage() if defined $pass;
	}
	my $id = $ppm->repo_add(name => $name, packlist_uri => $url);
	print "Repo $id added.\n";
    }
    elsif ($cmd =~ /^\d+$/) {
	@ARGV = ("describe") unless @ARGV;
	if ($ARGV[0] =~ /^\d+$/) {
	    # avoids infinite recursion
	    $USAGE = "repo <num> <cmd> ...";
	    usage();
	}
	splice(@ARGV, 1, 0, $cmd);
	do_repo();
    }
    elsif ($cmd eq "suggest") {
	eval {
	    require PPM::Repositories;
	    require ActivePerl;
	    my $count = 0;
	    for my $id (sort keys %PPM::Repositories::Repositories) {
		my $repo = $PPM::Repositories::Repositories{$id};
		next unless $repo->{Active};
		next if $repo->{Type} eq "PPMServer";
		my $o = $repo->{PerlO} || [];
		next if @$o && !grep $_ eq $^O, @$o;
		my $v = $repo->{PerlV} || [];
		my $my_v = ActivePerl::perl_version;
		next if @$v && !grep $my_v =~ /^\Q$_\E\b/, @$v;
		print "\n$PROGNAME repo add $id\n";
		print "   $repo->{Notes}\n";
		print "   $repo->{location}\n";
		$count++;
	    }
	    unless ($count) {
		die "No suggested repository for this perl";
	    }
	};
	if ($@) {
	    if ($@ =~ /^Can't locate/) {
		die "Install the PPM-Repositories package first";
	    }
	    else {
		die $@;
	    }
	};
    }
    else {
	$USAGE = "repo <cmd> <args>";
	usage("The repo command '$cmd' isn't recognized; try one of list, describe, add, delete, on, off, suggest");
    }
}

sub do_search {
    $USAGE = "search <pattern>";
    usage() unless @ARGV == 1;
    my $pattern = shift(@ARGV);
    $ppm->repo_sync;
    my @fields = ("name", "version", "release_date", "abstract");
    my @res = $ppm->search($pattern, @fields);
    if (@res) {
	if (@res == 1) {
	    @ARGV = (1);
	    return do_describe();
	}
	elsif (@res < 10) {
	    my $count = 0;
	    for (@res) {
		my($name, $version, $date, $abstract) = @$_;
		$count++;
		print "\n" unless $count == 1;
		print "$count: $name\n";
		print "   $abstract\n" if $abstract;
		print "   Version: $version\n";
		if ($date) {
		    $date =~ s/[T ].*//;
		    print "   Released: ", $date, "\n";
		}
	    }
	}
	else {
	    my $count = 0;
	    my $count_width = length(@res);
	    for (@res) {
		$count++;
		printf "%*d: %s v%s\n", $count_width, $count, $_->[0], $_->[1];
	    }
	}
    }
    else {
	print "*** no packages matching '$pattern' found ***\n";
    }
}

sub do_describe {
    $USAGE = "describe <num>";
    usage() unless @ARGV == 1;
    my $num = shift(@ARGV);
    $num =~ s/:$//;
    usage unless $num =~ /^\d+$/;
    my $pkg = $ppm->search_lookup($num) ||
	die "*** no package #$num, do a '$PROGNAME search' first ***\n";
    my $pad = " " x (length($num) + 2);
    print "$num: $pkg->{name}\n";
    print "${pad}$pkg->{abstract}\n" if $pkg->{abstract};
    print "${pad}Version: $pkg->{version}\n";
    if (my $date = $pkg->{release_date}) {
	$date =~ s/[T ].*//;
	print "${pad}Released: ", $date, "\n";
    }
    print "${pad}Author: $pkg->{author}\n" if $pkg->{author};
    for my $role (qw(provide require)) {
	for my $feature (sort keys %{$pkg->{$role} || {}}) {
	    next if $feature eq $pkg->{name};
	    (my $pretty_feature = $feature) =~ s/::$//;
	    print "${pad}\u$role: $pretty_feature";
	    if (my $vers = $pkg->{$role}{$feature}) {
		print " version $vers";
		print " or better" if $role eq "require";
	    }
	    print "\n";
	}
    }
    my $repo = $ppm->repo($pkg->{repo_id});
    print "${pad}Repo: $repo->{name}\n";
    print "${pad}CPAN: http://search.cpan.org/dist/$pkg->{name}-$pkg->{version}/\n";
    return;
}

sub do_install {
    $USAGE = "install [--force] [--nodeps] [--area <area>] <module> | <url> | <file> | <num>";
    my $force;
    my $nodeps;
    my $area;
    require Getopt::Long;
    Getopt::Long::GetOptions(
        force => \$force,
	'area=s' => \$area,
	nodeps => \$nodeps,
     ) || usage();
    usage() unless @ARGV == 1;
    my @args;
    push(@args, force => 1) if $force;
    push(@args, follow_deps => "none") if $nodeps;

    my $feature = shift(@ARGV);
    if ($feature =~ m,^[a-z][+\w]+:[^:],) {
	# looks like an absolute URL
	_install_uri($area, $feature, @args);
    }
    elsif ($feature =~ /\.ppd$/) {
	require URI::file;
	_install_uri($area, URI::file->new_abs($feature), @args);
    }
    elsif ($feature =~ /^\d+$/) {
	my $pkg = $ppm->search_lookup($feature) ||
	    die "*** no package #$feature, do a '$PROGNAME search' first ***\n";
	my @deps = $ppm->packages_missing(want_deps => [$pkg], @args);
	_install($area, $pkg, @deps);
    }
    else {
	# seach for feature in repos
	_install_repo($area, want => [$feature], @args);
    }
}

sub do_upgrade {
    $USAGE = "upgrade <module>";
    usage() unless @ARGV == 1;
    my $feature = shift(@ARGV);
    _install_repo(undef, want => [[$feature, undef]]);
}

sub _install_uri {
    my $area = shift;
    my $uri = shift;
    my @args = @_;

    my $res = web_ua->get($uri);
    unless ($res->is_success) {
	die $res->status_line;
    }
    require ActivePerl::PPM::PPD;
    my $cref = $res->decoded_content(ref => 1);
    my $pkg = ActivePerl::PPM::Package->new_ppd($$cref, $ppm->arch);
    unless ($pkg) {
	die "No PPD found _at $uri";
    }
    if (my $codebase = $pkg->{codebase}) {
	# make it absolute
	$pkg->{codebase} = URI->new_abs($codebase, $res->base)->rel($uri)->as_string;
	$pkg->{ppd_uri} = $uri;
	$pkg->{ppd_etag} = $res->header("ETag");
	$pkg->{ppd_lastmod} = $res->header("Last-Modified");
    }
    else {
	die "The PPD does not provide code to install for this platform";
    }

    # XXX follow dependencies with the "directory" of $pkg $uri as the
    # first repo to look for additional packages.  This only works for
    # package features.

    _install($area, $pkg, $ppm->packages_missing(want_deps => [$pkg], @args));
}

sub _install_repo {
    my $area = shift;
    $ppm->repo_sync;
    _install($area, $ppm->packages_missing(@_));
}

sub _install {
    my $area = shift;
    unless (@_) {
	print "No missing packages to install\n";
	return;
    }

    $| = 1;
    my $verbose = 0;
    my $ua = web_ua();
    unless ($area) {
	$area = $ppm->default_install_area;
	die "No default install area; please specify one with the --area option"
	    unless $area;
	ppm_log("NOTICE", "Installing into $area");
    }
    $area = $ppm->area($area);

    my $tmpdir = do { require File::Temp; File::Temp::tempdir("ppm-XXXXXX", TMPDIR => 1) };
    eval {
	$ppm->package_set_abs_ppd_uri(@_);

	# determine codebase_file
	for my $pkg (@_) {
	    my $name = $pkg->name_version;
	    my $codebase = $pkg->{codebase};
	    die "No codebase for $name" unless $codebase;
	    $codebase = URI->new_abs($codebase, $pkg->{ppd_uri});

	    if ($codebase =~ /\.(tgz|tar\.gz)$/) {
		$pkg->{codebase_type} = "tgz";
	    }
	    die "Don't know how to unpack $codebase" unless $pkg->{codebase_type};

	    if ($codebase->scheme eq 'file') {
		$pkg->{codebase_file} = $codebase->file;
		unless (-f $pkg->{codebase_file}) {
		    die "No file _at $pkg->{codebase_file}";
		}
	    }
	    else {
		print "Downloading $name...";
		my $save = $pkg->{codebase_file} = "$tmpdir/$name.$pkg->{codebase_type}";
		#print "\n    $codebase ==> $save...";
		my $res = $ua->get($codebase, ":content_file" => $save);
		die $res->status_line unless $res->is_success;
		if (my $len = $res->content_length) {
		    my $save_len = -s $save;
		    if ($save_len != $len) {
			die "Aborted download ($len bytes expected, got $save_len).\n";
		    }
		}
		# XXX An MD5 checksum for the tarball would be a good thing
		print "done\n";
	    }
	}

	# unpack
	for my $pkg (@_) {
	    my $pname = $pkg->name_version;
	    print "Unpacking $pname...";
	    my $codebase_file = $pkg->{codebase_file};
	    if ($pkg->{codebase_type} eq "tgz") {
		require Archive::Tar;
		require ExtUtils::MakeMaker;
		require ActiveState::ModInfo;
		ppm_log("DEBUG", "Unpacking $codebase_file");
		my $tar = Archive::Tar->new($codebase_file, 1);
		for my $file ($tar->get_files) {
		    next unless $file->is_file;  # don't extract links and other crap
		    my $fname = $file->full_path;
		    next if $fname =~ m,/\.exists$,;       # don't think these are needed
		    next if $fname =~ m,/html/(bin|site/lib)/,;  # will always regenerate these
		    my $extract = $fname;
		    next unless $extract =~ s,^blib/,$pname/,;
		    $extract = "$tmpdir/$extract";
		    $tar->extract_file($fname, $extract)
			|| die "Can't extract to $extract";
		    if ($fname =~ /\.pm$/) {
			my $mod = $fname;
			if ($mod =~ s,^blib/(?:lib|arch)/,,) {
			    $mod = ActiveState::ModInfo::fname2mod($mod);
			    $mod .= "::" unless $mod =~ /::/;
			    $pkg->{provide}{$mod} = MM->parse_version($extract) || 0;
			}

		    }
		}
		$pkg->{blib} = "$tmpdir/$pname";
	    }
	    else {
		die "Don't know how to unpack $pkg->{codebase_type} files";
	    }
	    print "done\n";
	}

	# relocate
	if ($^O ne "MSWin32") {
	    require ActiveState::RelocateTree;
	    my $ppm_sponge = ActiveState::RelocateTree::spongedir('ppm');
	    my $prefix = do { require Config; $Config::Config{prefix} };
	    for my $pkg (@_) {
		print "Relocating ", $pkg->name_version, "...";
		ActiveState::RelocateTree::relocate (
		    to      => $pkg->{blib},
		    inplace => 1,
	            search  => $ppm_sponge,
	            replace => $prefix,
                    quiet   => 1,
		);
		print "done\n";
	    }
	}

	# generate HTML from the POD
	if (eval { require ActivePerl::DocTools; }) {
	    require Cwd;
	    my $pwd = Cwd::cwd();
	    chdir($tmpdir) || die "Can't chdir $tmpdir: $!";
	    eval {
		for my $pkg (@_) {
		    my $pname = $pkg->name_version;
		    print "Generating HTML for $pname...";
		    ActivePerl::DocTools::UpdateHTML_blib(verbose => 0, blib => $pname);
		    print "done\n";
		}
	    };
	    chdir($pwd) || die "Can't chdir back to $pwd: $!";
	    die $@ if $@;
	}

	# install
	my $to = $area->name;
	$to = " to $to area" if $to;
	print "Installing$to...";
	if (my $summary = $area->install(@_)) {
	    print "done\n";
	    for my $what (sort keys %$summary) {
		my $n = $summary->{$what} || 0;
		printf "%4d file%s %s\n", $n, ($n == 1 ? "" : "s"), $what;
	    }
	}
	else {
	    print "\n";
	    die $@;
	}

	# run install scripts
	for my $pkg (@_) {
	    _run_script($area, $pkg, "install", $tmpdir);
	}
    };
    my $err = $@;
    require File::Path;
    File::Path::rmtree($tmpdir, $verbose);
    die $err if $err;
}

sub _run_script {
    my($area, $pkg, $kind, $tmpdir) = @_;
    my $script = $pkg->{script}{$kind};
    return unless $script;

    $tmpdir ||= do { require File::Temp; File::Temp::tempdir("ppm-XXXXXX", TMPDIR => 1, CLEANUP => 1) };

    my @commands;
    if (defined(my $uri = $script->{uri})) {
	print "Downloading ", $pkg->name_version, " $kind script...";
	my $res = web_ua()->get(URI->new_abs($uri, $pkg->{ppd_uri}));
	die $res->status_line unless $res->is_success;
	if (my $len = $res->content_length) {
	    my $save_len = length($res->content);
	    if ($save_len != $len) {
		die "Aborted download ($len bytes expected, got $save_len).\n";
	    }
	}
	if ($script->{exec}) {
	    my $file = "$tmpdir/${kind}_script";
	    open(my $fh, ">:utf8", $file) || die "Can't create $file: $!";
	    print $fh $res->decoded_content;
	    close($fh) || die "Can't write $file: $!";
	    chmod(0755, $file);
	    push(@commands, _expand_exec($script->{exec}, "${kind}_script"));
	}
	else {
	    push(@commands, grep length, split(/\n/, $res->decoded_content));
	}
	print "done\n";
    }
    else {
	if (my $exec = $script->{exec}) {
	    my $text = $script->{text};
	    $text =~ s/;;/\n/g;  # what ugliness

	    my $file = "$tmpdir/${kind}_script";
	    open(my $fh, ">", $file) || die "Can't create $file: $!";
	    print $fh $text;
	    close($fh) || die "Can't write $file: $!";
	    chmod(0755, $file);

	    push(@commands, _expand_exec($script->{exec}, "${kind}_script"));
	}
	else {
	    push(@commands, grep length, split(/;;/, $script->{text}));
	}
    }
    if (@commands) {
	require ActiveState::Run;
	require Cwd;
	my $old_cwd = Cwd::cwd();
	local $ENV{PPM_INSTROOT} = $area->prefix;
	local $ENV{PPM_INSTLIB} = $area->lib;
	local $ENV{PPM_INSTARCHLIB} = $area->archlib;
	local $ENV{PPM_VERSION} = do { require ActivePerl::PPM; $ActivePerl::PPM::VERSION };
	local $ENV{PPM_ACTION} = $kind;  # XXX 'upgrade'
	# local $ENV{PPM_PREV_VERSION} = ...;
	# local $ENV{PPM_NEW_VERSION} = ...;
	# local $ENV{PPM_INSTPACKLIST} = ....;
	local $ENV{PPM_PERL} = $^X;
	eval {
	    chdir $tmpdir;
	    print "Running ", $pkg->name_version, " $kind script...\n";
	    for my $cmd (@commands) {
		ActiveState::Run::run(ref($cmd) ? @$cmd : $cmd);
	    }
	};
	chdir($old_cwd) || die "Can't chdir back to '$old_cwd': $!";
	die if $@;
    }
}

sub _expand_exec {
    my $exec = shift;
    if (uc($exec) eq "SELF") {
	$exec = shift;
	$exec = "./$exec" if $^O ne "MSWin32";
    }
    elsif (uc($exec) eq "PPM_PERL" || $exec eq "perl") {
	$exec = $^X;
    }
    $exec = '@' . $exec;  # silence command echo
    return [$exec, @_];
}

sub do_remove {
    $USAGE = "remove [--area <area>] <package> ...";
    my $opt_area;
    require Getopt::Long;
    Getopt::Long::GetOptions(
	'area=s' => \$opt_area,
     ) || usage();
    usage() unless @ARGV;

    my $removed_count = 0;
    for my $pkg (@ARGV) {
	my $area; ($opt_area ? $ppm->area($opt_area) : ());
	my $pkg_o;
	if ($opt_area) {
	    $area =  $ppm->area($opt_area);
	    $pkg_o = $area->package($pkg);
	}
	else {
	    for my $a ($ppm->areas) {
		$area = $ppm->area($a);
		$pkg_o = $area->package($pkg);
		if ($pkg_o) {
		    die "Can't remove from 'perl' area without explicit area specification"
			if $a eq "perl";
		    last;
		}
	    }
	}
	unless ($pkg_o) {
	    print "$pkg: not installed\n";
	    next;
	}
	eval {
	    _run_script($area, $pkg_o, "uninstall");
	    print "$pkg: ";
	    $area->uninstall($pkg);
	};
	if ($@) {
	    $@ =~ s/ at .*// unless $ENV{ACTIVEPERL_PPM_DEBUG};
	    print $@;
	}
	else {
	    print "uninstalled\n";
	    $removed_count++;
	}
    }
    die "No packages uninstalled" unless $removed_count;
}

BEGIN {
    # aliases for PPM3 compatibility (mostly)
    *do_update = \&do_upgrade;
    *do_uninstall = \&do_remove;
}

__END__

=head1 NAME

ppm - Perl Package Manager, version 4

=head1 SYNOPSIS

Invoke the graphical shell (not implemented yet):

    ppm

Install, upgrade and remove packages:

    ppm install [--area <area>] [--force] <pkg>
    ppm install [--area <area>] [--force] <module>
    ppm install [--area <area>] <url>
    ppm install [--area <area>] <file>.ppd
    ppm install [--area <area>] <num>
    ppm upgrade <pkg>
    ppm upgrade <module>
    ppm remove [--area <area>] <pkg>

Manage and search install areas:

    ppm area list [--csv] [--no-header]
    ppm area sync
    ppm list [--name] [--version] [--abstract] ...
    ppm list <area> [--name] [--version] [--abstract] ...
    ppm files <pkg>
    ppm verify [<pkg>]

Manage and search repositories:

    ppm repo list [--csv] [--no-header]
    ppm repo sync [--force]
    ppm repo on <num>
    ppm repo off <num>
    ppm repo describe <num>
    ppm repo add <url> [<name>] [--username <user> [--password <passwd>]]
    ppm repo suggest
    ppm search <pattern>
    ppm describe <num>

Obtain version and copyright information about this program:

    ppm --version
    ppm version

=head1 DESCRIPTION

The C<ppm> program is the package manager for ActivePerl.  It
simplifies the task of locating, installing, upgrading and removing
Perl packages.

Invoking C<ppm> without arguments brings up the graphical shell (not
implemented yet), but ppm can also be used as a command line tool where
the first argument provide the name of the sub-command to invoke.
The following sub-commands are recognized:

=over

=item B<ppm area list> [ B<--csv> [ I<sep> ] ] [ B<--no-header> ]

Lists the available install areas.  The list displays the name, number
of installed packages and C<lib> directory location for each install
area.  If that area is read-only, the name appears in parenthesis.  You
will not be able to install packages or remove packages in these areas.
The default install area is marked with a C<*> after its name.

PPM B<install areas> are basically perl library locations.  PPM allows
for the addition of new install areas, which is useful for shared
ActivePerl installations where the user does not have write permissions
for the I<site> and I<perl> library directories.  New install areas are
added by specifying the target directory in the PERL5LIB environment
variable.

The order of the listed install areas is the order perl uses when
searching for modules.  Modules installed in earlier areas override
modules installed in later ones.

The B<--csv> option selects CSV (comma-separated values) format for the
output. The default field separator can be overridden by the argument
following B<--cvs>.

The B<--no-header> option suppresses column headings.

=item B<ppm area sync> [ I<area> ... ]

Synchronizes installed packages, including those installed by means
other than PPM (e.g. the CPAN shell), with the ppm database. PPM
searches the install area(s) for packages, making PPM database entries
if they do not already exist, or dropping entries for packages that no
longer exist.  When used without an I<area> argument, all install areas
are synced. 

=item B<ppm dump> [ I<what> ]

Internal debugging tool.

=item B<ppm describe> I<num>

Shows all properties for a particular package from the last search
result.

=item B<ppm files> I<pkg>

Lists the full path name of the files belonging to the given package,
one line per file.

=item B<ppm help> [ I<subcommand> ]

Prints the documentation for ppm (this file).

=item B<ppm install> I<pkg> [ B<--area> I<area> ] [ B<--force> ] [ B<--nodeps> ]

=item B<ppm install> I<module> [ B<--area> I<area> ] [ B<--force> ] [ B<--nodeps> ]

=item B<ppm install> I<file>.ppd [ B<--area> I<area> ] [ B<--nodeps> ]

=item B<ppm install> I<url> [ B<--area> I<area> ] [ B<--nodeps> ]

=item B<ppm install> I<num> [ B<--area> I<area> ] [ B<--nodeps> ]

Install a package and its dependencies.

The argument to B<ppm install> can be the name of a package, the name of
a module provided by the package, the file name or the URL of a PPD file,
or the associated number for the package returned by the last C<ppm
search> command. 

If the package or module requested is already installed, PPM installs
nothing.  The B<--force> option can be used to make PPM install a
package even if its already present.

By default, new packages are installed in the C<site> area, but if the
C<site> area is read only, and there are user-defined areas set up, the
first user-defined area is used as the default instead.  Use the
B<--area> option to install the package into an alternative location.

The B<--nodeps> option makes PPM attempt to install the package
without resolving any dependencies the package might have.

=item B<ppm list> [ I<area> ] [ B<--matching> I<pattern> ]  [ B<--csv> [ I<sep> ] ] [ B<--no-header> ] [ --I<field> ... ]

List installed packages.  If the I<area> argument is not provided, list
the content of all install areas.

The B<--matching> option limits the output to only include packages
matching the given I<pattern>.  See B<ppm search> for I<pattern> syntax.

The B<--csv> option selects CSV (comma-separated values) format for the
output. The default field separator can be overridden by the argument
following B<--cvs>.

The B<--no-header> option suppress printing of the column headings.

The following fields can be shown:

=over

=item B<--name>

The package name.  This field is always shown first, but if specified
alone just the package name is listed.

=item B<--version>

The version number of the package.

=item B<--date>

The release date of the package.

=item B<--abstract>

A one sentence description of the purpose of the package.

=item B<--author>

The package author or maintainer.

=item B<--area>

Where the package is installed.

=item B<--files>

The number of files installed for the package.

=item B<--size>

The combined disk space used for the package.

=item B<--ppd>

The location of the package description file.

=back

=item B<ppm query> I<pattern>

Alias for B<ppm list --matching> I<pattern>.  Provided for PPM version
3 compatibility.

=item B<ppm remove> I<pkg> ...

Uninstalls the specified package.

=item B<ppm rep> ...

Alias for B<ppm repo>.  Provided for PPM version 3 compatibility.

=item B<ppm repo>

Alias for B<ppm repo list>.

=item B<ppm repo add> I<url> [ I<name> ] [ B<--username> I<user> [ B<--password> I<password> ]

Set up a new repository for PPM to fetch packages from.

=item B<ppm repo delete> I<num>

Remove repository number I<num>.

=item B<ppm repo describe> I<num>

Show all properties for repository number I<num>.

=item B<ppm repo list> [ B<--csv> [ I<sep> ] ] [ B<--no-header> ]

List the repositories that PPM is currently configured to use.  Use this
to identify which number specifies a particular repository.

The B<--csv> option selects comma-separated values format for the
output. The default field separator can be overridden by the argument
following B<--cvs>.

The B<--no-header> option suppress printing of the column headings.


=item B<ppm repo> I<num>

Alias for B<ppm repo describe> I<num>.

=item B<ppm repo> I<num> I<cmd>

Alias for B<ppm repo> I<cmd> I<num>.

=item B<ppm repo off> I<num>

Disable repository number I<num> for B<ppm install> or B<ppm search>.

=item B<ppm repo on> I<num>

Enable repository number I<num> if it has been previously disabled with
B<ppm repo off>.

=item B<ppm repo search> ...

Alias for B<ppm seach>.

=item B<ppm repo suggest>

List some known repositories that can be added with B<ppm add>. PPM
needs the C<PPM-Repositories> package to be installed in the I<perl>
install area for this option to work. To install it:

  ppm install PPM-Repositories --area perl

This package supplies PPM with a list of repositories maintained by
third parties (not by ActiveState). For example, to add the theoryx5
repository:

  ppm repo add theory58S

=item B<ppm repo sync> [ B<--force> ]

Synchronize local cache of packages found in the enabled repositories.
With the B<--force> option, download state from remote repositories even
if the local state has not expired yet.

=item B<ppm search> I<pattern>

Search for packages matching I<pattern> in all enabled repositories.

For I<pattern>, use the wildcard C<*> to match any number of characters
and the wildcard C<?> to match a single character.  For example, to find
packages starting with the string "List" search for C<list*>. Searches
are case insensitive.  

If I<pattern> contains C<::>, PPM will search for packages that provide
modules matching the pattern.

If I<pattern> matches the name of a package exactly (case-sensitively),
only that package is shown.  A I<pattern> without wildcards that does
not match any package names exactly is used for a substring search
against available package names (i.e. treated the same as
"B<*>I<pattern>B<*>").

The output format depends on how many packages match.  If there is only
one match, the B<ppm describe> format is used.  If only a few packages
match, limited information is displayed.  If many packages match, only
the package names and version numbers are displayed, one per line.

The number prefixing each entry in search output can be used to look
up full information with B<ppm describe> I<num> or to install the
package with B<ppm install> I<num>.

=item B<ppm uninstall> ...

Alias for B<ppm remove>.

=item B<ppm update> ...

Alias for B<ppm upgrade>.

=item B<ppm upgrade> I<pkg>

=item B<ppm upgrade> I<module>

Upgrades the specified package or module if an upgrade is available in
one of the currently enabled repositories.

=item B<ppm verify> [ I<pkg> ]

Checks that the installed files are still present and unmodified.  If
the package name is given, only that packages is verified.

=item B<ppm version>

Will print the version of PPM and a copyright notice.

=back

=head1 FILES

The following lists files and directories that PPM uses and creates:

=over

=item F<$HOME/.ActivePerl/>

Directory where PPM keeps its state.  On Windows this directory is
F<$APPDATA/ActiveState/ActivePerl/>.  Perl version specific
subdirectories can be created if you do not want the versions to share
state.  For example, if you create F<$HOME/.ActivePerl/5.8.8.818/>,
build 818 of ActivePerl will keep its state there.

=item F<$HOME/.ActivePerl/ppm-$ARCH.db>

SQLite database where ppm keeps its configuration and caches meta
information about the content of the enabled repositories.

=item F<$HOME/ppm4.log>

Log file created to record actions that PPM takes.  On Windows this is
logged to F<$TEMPDIR/ppm4.log>.

=item F<$PREFIX/etc/ppm-$NAME-area.db>

SQLite database where PPM tracks packages installed in the install area
under C<$PREFIX>.

=item F<$TEMPDIR/ppm-XXXXXX/>

Temporary directories used during install.  Packages to be installed
are unpacked here.

=item F<*.ppd>

XML files containing meta information about packages.  Each package has
its own .ppd file.  See L<ActivePerl::PPM::PPD> for additional
information.

=item F<package.xml>

Meta information about repositories.  When a repository is added, PPM 
looks for this file and if present, monitors it too stay in sync with
the state of the repository.

=item F<package.lst>

Same as F<package.xml> but PPM 3 compatible.  PPM will use this file
if F<package.xml> is not available.

=back

=head1 ENVIRONMENT

The following environment variables affect how PPM behaves:

=over

=item C<ACTIVEPERL_PPM_DEBUG>

If set to a TRUE value, makes PPM print more internal diagnostics.

=item C<ACTIVEPERL_PPM_BOX_CHARS>

Select what kind of box drawing characters to use for the C<ppm *
list> outputs.  Valid values are C<ascii>, C<dos> and C<unicode>.  The
default varies.

=item C<ACTIVEPERL_PPM_HOME>

If set, use this directory instead of F<~/.ActivePerl/> to store
configuration information for PPM.

=item C<ACTIVEPERL_PPM_LOG_CONS>

If set to a TRUE value, make PPM print any log output to the console as
well.

=item C<DBI_TRACE>

PPM uses L<DBI> to access the internal SQLite databases. Setting
DBI_TRACE allow you to see what queries are performed.  Output goes to
STDERR.  See L<DBI> for further details.

=back

=head1 WHAT'S NEW IN VERSION 4

PPM version 4 is a complete rewrite.  The main changes since PPM version 3 are:

=over

=item *

The command line shell has been replaced with a graphical shell (not
implemented yet, but will be in Beta 2).

=item *

PPM can now manage different installation areas.

=item *

No more 'precious' packages.  PPM can upgrade itself as well other
bundled and core modules.

=item *

Installation of packages and their dependencies happen as atomic
transactions.

=item *

PPM tracks what files it has installed and can notice if files have been
modified or deleted.  The command 'ppm verify' will report on
mismatches.

=item *

State is kept in local SQLite databases.  All repository state is kept
local which makes searching much faster.

=item *

PPM will pick up and manage packages installed by other means (e.g.
manually or with the CPAN shell).

=item *

No more SOAP.

=item *

Underlying modules moved to the C<ActivePerl::PPM::> namespace.

=back

=head1 SEE ALSO

L<activeperl>

L<http://search.cpan.org/dist/PPM-Repositories/>

=head1 COPYRIGHT

Copyright (C) 2006 ActiveState Software Inc.  All rights reserved.

=cut
