#!/usr/bin/perl -w

use strict;
use ActivePerl::PPM::limited_inc;

use ActivePerl::PPM::Client;
use ActivePerl::PPM::Web qw(web_ua);
use ActivePerl::PPM::Logger qw(ppm_log);
use File::Path qw(mkpath rmtree);

$SIG{__WARN__} = sub { ppm_log("WARNING", $_[0]) };

(my $PROGNAME = $0) =~ s,.*[\\/],,;

my $CMD = shift || gui();
$CMD = "version" if $CMD eq "--version";

my $do_cmd = "do_$CMD";
usage("Unrecognized ppm command '$CMD'") unless defined &$do_cmd;

my $ppm = ActivePerl::PPM::Client->new;

eval {
    no strict 'refs';
    ppm_log("INFO", "$PROGNAME $CMD" . (@ARGV ? " @ARGV" : ""));
    &$do_cmd;
};
if ($@) {
    ppm_log("ERR", "$PROGNAME $CMD: $@");
    $@ =~ s/ at .*// unless $ENV{ACTIVEPERL_PPM_DEBUG};
    print STDERR "$PROGNAME $CMD failed: $@";
    exit 1;
}
else {
    exit;
}

my $USAGE;
sub usage {
    my $msg = shift;
    if ($msg) {
	$msg .= "\n" unless $msg =~ /\n$/;
	print STDERR $msg;
    }
    $USAGE ||= "<cmd> <arg>...";
    print STDERR "Usage:\t$PROGNAME $USAGE\n";
    print STDERR "\tRun '$PROGNAME help" . ($USAGE =~ /^(\w+)/ ? " $1" : "") . "' to learn more.\n";
    exit 1;
}

sub gui {
    usage("The graphical shell has not been implemented yet.");
}

sub do_dump {
    require Data::Dump;
    push(@ARGV, "client") unless @ARGV;
    for my $what (@ARGV) {
	if ($what eq "client") {
	    Data::Dump::dump($ppm);
	}
	elsif (grep $_ eq $what,$ppm->area) {
	    Data::Dump::dump($ppm->area($what));
	}
	elsif (grep $_ eq $what, $ppm->repos) {
	    Data::Dump::dump($ppm->repo($what));
	}
	elsif (my $pkg = $ppm->current_area->package($what)) {
	    Data::Dump::dump($pkg);
	}
	else {
	    warn "No area/repo/package called $what\n";
	}
    }
}

sub do_version {
    if (@ARGV) {
	$USAGE = "version";
	usage("The $CMD command does not take arguments.");
    }
    require ActivePerl::PPM;
    print "ppm $ActivePerl::PPM::VERSION (Beta 1)\n";
    print "Copyright (C) 2006 ActiveState Software Inc.  All rights reserved.\n";
}

sub do_help {
    if (@ARGV > 1) {
	$USAGE = "help [<subcommand>]";
	usage();
    }
    open(my $fh, "<", __FILE__) || die "Can't open " . __FILE__ . ": $!";
    if (@ARGV) {
	my $cmd = shift(@ARGV);
	my $foundit;
	while (<$fh>) {
	    if (/^=item B<ppm \Q$cmd\E>/o) {
		$foundit++;
		last;
	    }
	}
	if ($foundit) {
	    open(my $out, "| pod2text");
	    print $out "=over\n\n";
	    print $out $_;
	    my $over_depth = 0;
	    while (<$fh>) {
		last if /^=item B<ppm (?!\Q$cmd\E>)/o;
		if (/^=back\b/) {
		    last if $over_depth == 0;
		    $over_depth--;
		}
		elsif (/^=over\b/) {
		    $over_depth++;
		}
		print $out $_;
	    }
	    print $out "\n\n=back\n";
	    close($out);
	}
	else {
	    print "Sorry, no help for '$cmd'\n";
	}
    }
    else {
	use ActivePerl::PPM;
	my $pager = $ENV{PAGER} || "more";
	open(my $out, "| pod2text | $pager");
	while (<$fh>) {
	    s/version \d+\S*/version $ActivePerl::PPM::VERSION/ if /^ppm -/;
	    print $out $_;
	}
	close($out);
    }
}

sub do_area {
    my $current = $ppm->current_area_name;
    my $show_header = 1;
    if (@ARGV) {
	my $new_current;
	my $sync;
	$USAGE = "area [--current [<name>]] [--sync] [--no-header]";
	require Getopt::Long;
	Getopt::Long::GetOptions(
           'current:s' => \$new_current,
	   'sync' => \$sync,
           'header!' => \$show_header,
        ) || usage();
	usage() if @ARGV;
	if (defined $new_current) {
	    $ppm->current_area_name($new_current) if length($new_current);
	    $ppm->current_area->sync_db if $sync;
	    if (length($new_current)) {
		print "Current install area set to $new_current.\n";
	    }
	    else {
		print "$current\n";
	    }
	    return;
	}
	$ppm->current_area->sync_db if $sync;
    }
    if ($show_header) {
	print "cur name   pkg# lib\n";
	print "--- ------ ---- ------------------------------------\n";
    }
    for my $area ($ppm->area) {
	my $o = $ppm->area($area);
	printf "%3s %-6s %4d %s\n",
	    ($current eq $area ? "->" : ""),
	    $area,
	    scalar($o->packages),
	    $o->lib;
    }
}

sub do_list {
    my %opt;
    my $area_name;
    if (@ARGV) {
	$USAGE = "list [<area>] [--name] [--version] [--date] [--abstract] [--author] [--ppd] [--files] [--size]";
	require Getopt::Long;
	Getopt::Long::GetOptions(\%opt,
           'id',
           'name',
           'version',
           'date',
           'abstract',
           'author',
	   'files',
           'size',
           'ppd',
        ) || usage();
	$area_name = shift(@ARGV) if @ARGV;
	usage() if @ARGV;
    }
    unless (%opt) {
	$opt{version}++;
        $opt{date}++;
	$opt{files}++;
	$opt{size}++;
    }
    $opt{name}++;

    my $area = $area_name ? $ppm->area($area_name) : $ppm->current_area;
    if (keys %opt == 1) {
	# just list the names
	my $count;
	for my $pkg ($area->packages) {
	    print "$pkg\n";
	    $count++;
	}
	goto NO_PKG_INSTALLED unless $count;
    }
    else {
	my @fields;
	push(@fields, "name");
	push(@fields, "version") if $opt{version};
	push(@fields, "release_date") if $opt{date};
	push(@fields, "abstract") if $opt{abstract};
	push(@fields, "author") if $opt{author};
	push(@fields, "ppd_uri") if $opt{ppd};
	require ActiveState::Table;
	my $tab = ActiveState::Table->new;
	$tab->add_field($_) for @fields;
	$tab->add_field("files") if $opt{files};
	$tab->add_field("size") if $opt{size};
	for my $pkg ($area->packages(@fields)) {
	    my %row = map {$_ => shift(@$pkg)} @fields;
	    if ($row{release_date}) {
		$row{release_date} =~ s/T.*//;  # drop time
	    }
	    if ($opt{files} || $opt{size}) {
		my @files = $area->package_files($row{name});
		$row{files} = @files if $opt{files};
		$row{size} = do {
		    require ActiveState::DiskUsage;
		    my $size = 0;
		    $size += ActiveState::DiskUsage::du($_) for @files;
		    $size = sprintf "%.0f KB", $size / 1024;
		} if $opt{size};
	    }
	    $tab->add_row(\%row);
	}
	if (my $rows = $tab->rows) {
	    print $tab->as_box(null => "", show_trailer => 0, align => {files => "right", size => "right"});
	    if (1) {
		$area_name ||= $ppm->current_area_name;
		my $s = ($rows == 1) ? "" : "s";
		print " ($rows package$s installed in '$area_name' area)\n";
	    }
	}
	else {
	NO_PKG_INSTALLED:
	    $area_name ||= $ppm->current_area_name;
	    print STDERR "*** no packages installed in '$area_name' area ***\n";
	}
    }
}

sub do_files {
    $USAGE = "files <pkg>";
    usage() unless @ARGV == 1;
    print "$_\n" for $ppm->current_area->package_files($ARGV[0]);
}

sub do_verify {
    my %opt;
    if (@ARGV) {
	$USAGE = "verify [--verbose] [<package>]";
	require Getopt::Long;
	Getopt::Long::GetOptions(\%opt,
           'verbose',
        ) || usage();
	$opt{package} = shift(@ARGV) if @ARGV;
	usage() if @ARGV;
    }
    my $area = $ppm->current_area;
    my %status = $area->verify(%opt);
    for my $v (qw(verified missing modified)) {
	next if $v ne "verified" && !$status{$v};
	my $s = $status{$v} == 1 ? "" : "s";
	print "$status{$v} file$s $v.\n";
    }
}

sub uri_hide_passwd {
    my $url = shift;
    return $url unless $url =~ /\@/;
    $url = URI->new($url);
    if (my $ui = $url->userinfo) {
	if ($ui =~ s/:.*/:***/) {
	    $url->userinfo($ui);
	}
    }
    return $url->as_string;
}

sub do_repo {
    my $cmd = shift(@ARGV) || "list";
    if ($cmd eq "list") {
	$USAGE = "repo list";
	usage() if @ARGV;
	for my $repo_id ($ppm->repos) {
	    my $repo = $ppm->repo($repo_id);
	    my $status = $repo->{enabled} ? "" : "(OFF) ";
	    print "[$repo_id] $status$repo->{name} <" . uri_hide_passwd($repo->{packlist_uri}) . ">\n";
	}
    }
    elsif ($cmd eq "search") {
	do_search();
    }
    elsif ($cmd eq "sync") {
	$USAGE = "repo sync [--force]";
	my $force;
	if (@ARGV) {
	    require Getopt::Long;
	    Getopt::Long::GetOptions(
	        force => \$force,
            ) || usage();
	    usage() if @ARGV;
	}
	$ppm->repo_sync(force => $force);
    }
    elsif ($cmd eq "on" || $cmd eq "off" || $cmd eq "delete" || $cmd eq "describe") {
	$USAGE = "repo $cmd <num>";
	usage() if @ARGV != 1;
	my $repo = $ppm->repo($ARGV[0]);
	die "No such repo; 'ppm repo list' will print what's available" unless $repo;
	if ($cmd eq "delete") {
	    $ppm->repo_delete($ARGV[0]);
	}
	elsif ($cmd eq "describe") {
	    require ActiveState::Duration;
	    print "Id: $repo->{id}\n";
	    print "Name: $repo->{name}\n";
	    print "URL: " . uri_hide_passwd($repo->{packlist_uri}) . "\n";
	    print "Prio: $repo->{prio}\n";
	    print "Enabled: ", ($repo->{enabled} ? "yes" : "no"), "\n";
	    if (my $last_status = $repo->{packlist_last_status_code}) {
		print "Last-Status: $last_status " . HTTP::Status::status_message($last_status) . "\n";
	    }
	    else {
		print "Last-Status: - (never accessed)\n";
	    }
	    if (my $last_access = $repo->{packlist_last_access}) {
		print "Last-Access: ", ActiveState::Duration::ago_eng(time - $last_access), "\n";
	    }
	    if (my $fresh_until = $repo->{packlist_fresh_until}) {
		my $refresh_in = $fresh_until - time;
		if ($refresh_in >= 0) {
		    print "Refresh-In: ", ActiveState::Duration::dur_format_eng($refresh_in), "\n";
		}
		else {
		    print "Refresh-In: overdue\n";
		}
	    }
	    if (my $lastmod = $repo->{packlist_lastmod}) {
		require HTTP::Date;
		print "Last-Modified: ", ActiveState::Duration::ago_eng(time - HTTP::Date::str2time($lastmod)), "\n";
	    }
	}
	else {
	    $ppm->repo_enable($ARGV[0], $cmd eq "on");
	}
    }
    elsif ($cmd eq "add") {
	$USAGE = "repo add <url> [<name>] [--username <user> [--password <password>]]";
	my $user;
	my $pass;
	require Getopt::Long;
	Getopt::Long::GetOptions(
	    'username=s' => \$user,
            'password=s' => \$pass,
        ) || usage();
	my $url = shift(@ARGV) || usage();
	my $name;
	if (@ARGV) {
	    $name = shift(@ARGV);
	    usage() if @ARGV;
	    if ($url !~ /^[a-z][+\w]+:/ && $name =~ /^[a-z][+\w]+:/) {
		# ppm3 had the arguments reversed, so try that
		($url, $name) = ($name, $url);
	    }
	}
	else {
	    $name = eval { URI->new($url)->host } || $url;
	}
	unless ($url =~ /^[a-z][+\w]+:/) {
	    if (-d $url) {
		require URI::file;
		$url = URI::file->new_abs($url);
	    }
	    elsif (eval {require PPM::Repositories} and
		   my $repo = $PPM::Repositories::Repositories{$url})
	    {
		$name ||= $url;
		$url = $repo->{location};
	    }
	    else {
		die "The repository URL must be absolute or a local directory";
	    }
	}
	if ($user) {
	    $user .= ":$pass" if defined $pass;
	    $url = URI->new($url);
	    $url->userinfo($user);
	    $url = $url->as_string;
	}
	else {
	    usage() if defined $pass;
	}
	my $id = $ppm->repo_add(name => $name, packlist_uri => $url);
	print "Repo $id added.\n";
    }
    elsif ($cmd =~ /^\d+$/) {
	@ARGV = ("describe") unless @ARGV;
	if ($ARGV[0] =~ /^\d+$/) {
	    # avoids infinite recursion
	    $USAGE = "repo <num> <cmd> ...";
	    usage();
	}
	splice(@ARGV, 1, 0, $cmd);
	do_repo();
    }
    elsif ($cmd eq "suggest") {
	eval {
	    require PPM::Repositories;
	    require ActivePerl;
	    my $count = 0;
	    for my $id (sort keys %PPM::Repositories::Repositories) {
		my $repo = $PPM::Repositories::Repositories{$id};
		next unless $repo->{Active};
		next if $repo->{Type} eq "PPMServer";
		my $o = $repo->{PerlO} || [];
		next if @$o && !grep $_ eq $^O, @$o;
		my $v = $repo->{PerlV} || [];
		my $my_v = ActivePerl::perl_version;
		next if @$v && !grep $my_v =~ /^\Q$_\E\b/, @$v;
		print "\n$PROGNAME repo add $id\n";
		print "   $repo->{Notes}\n";
		print "   $repo->{location}\n";
		$count++;
	    }
	    unless ($count) {
		die "No suggested repository for this perl";
	    }
	};
	if ($@) {
	    if ($@ =~ /^Can't locate/) {
		die "Install the PPM-Repositories package first";
	    }
	    else {
		die $@;
	    }
	};
    }
    else {
	$USAGE = "repo <cmd> <args>";
	usage("The repo command '$cmd' isn't recognized; try one of list, describe, add, delete, on, off, suggest");
    }
}

sub do_search {
    $USAGE = "search <pattern>";
    usage() unless @ARGV == 1;
    my $pattern = shift(@ARGV);
    $ppm->repo_sync;
    my @fields = ("name", "version", "release_date", "abstract");
    my @res = $ppm->search($pattern, @fields);
    if (@res) {
	if (@res == 1) {
	    @ARGV = (1);
	    return do_describe();
	}
	elsif (@res < 10) {
	    my $count = 0;
	    for (@res) {
		my($name, $version, $date, $abstract) = @$_;
		$count++;
		print "\n" unless $count == 1;
		print "$count: $name\n";
		print "   $abstract\n" if $abstract;
		print "   Version: $version\n";
		if ($date) {
		    $date =~ s/T.*//;
		    print "   Released: ", $date, "\n";
		}
	    }
	}
	else {
	    my $count = 0;
	    my $count_width = length(@res);
	    for (@res) {
		$count++;
		printf "%*d: %s v%s\n", $count_width, $count, $_->[0], $_->[1];
	    }
	}
    }
    else {
	print "*** no packages matching '$pattern' found ***\n";
    }
}

sub do_describe {
    $USAGE = "describe <num>";
    usage() unless @ARGV == 1;
    my $num = shift(@ARGV);
    $num =~ s/:$//;
    usage unless $num =~ /^\d+$/;
    my $pkg = $ppm->search_lookup($num) ||
	die "*** no package #$num, do a '$PROGNAME search' first ***\n";
    my $pad = " " x (length($num) + 2);
    print "$num: $pkg->{name}\n";
    print "${pad}$pkg->{abstract}\n" if $pkg->{abstract};
    print "${pad}Version: $pkg->{version}\n";
    if (my $date = $pkg->{release_date}) {
	$date =~ s/T.*//;
	print "${pad}Released: ", $date, "\n";
    }
    print "${pad}Author: $pkg->{author}\n" if $pkg->{author};
    for my $role (qw(provide require)) {
	for my $feature (sort keys %{$pkg->{$role} || {}}) {
	    next if $feature eq $pkg->{name};
	    (my $pretty_feature = $feature) =~ s/::$//;
	    print "${pad}\u$role: $pretty_feature";
	    if (my $vers = $pkg->{$role}{$feature}) {
		print " version $vers";
		print " or better" if $role eq "require";
	    }
	    print "\n";
	}
    }
    my $repo = $ppm->repo($pkg->{repo_id});
    print "${pad}Repo: $repo->{name}\n";
    print "${pad}CPAN: http://search.cpan.org/dist/$pkg->{name}-$pkg->{version}/\n";
    return;
}

sub do_install {
    $USAGE = "install [--force] <module> | <url> | <file> | <num>";
    my $force;
    require Getopt::Long;
    Getopt::Long::GetOptions(
        force => \$force,
     ) || usage();
    usage() unless @ARGV == 1;
    my $feature = shift(@ARGV);
    if ($feature =~ m,^[a-z][+\w]+:[^:],) {
	# looks like an absolute URL
	_install_uri($feature);
    }
    elsif ($feature =~ /\.ppd$/) {
	require URI::file;
	_install_uri(URI::file->new_abs($feature));
    }
    elsif ($feature =~ /^\d+$/) {
	my $pkg = $ppm->search_lookup($feature) ||
	    die "*** no package #$feature, do a '$PROGNAME search' first ***\n";
	$ppm->package_set_abs_ppd_uri($pkg);
	_install($pkg);
    }
    else {
	# seach for feature in repos
	_install_repo($feature, 0, force => $force);
    }
}

sub do_upgrade {
    $USAGE = "upgrade <module>";
    usage() unless @ARGV == 1;
    my $feature = shift(@ARGV);
    _install_repo($feature, undef);
}

sub _install_uri {
    my $uri = shift;
    my $res = web_ua->get($uri);
    unless ($res->is_success) {
	die $res->status_line;
    }
    require ActivePerl::PPM::PPD;
    my $cref = $res->decoded_content(ref => 1);
    my $pkg = ActivePerl::PPM::Package->new_ppd($$cref);
    unless ($pkg) {
	die "No PPD found at $uri";
    }
    if (my $codebase = $pkg->{codebase}) {
	# make it absolute
	$pkg->{codebase} = URI->new_abs($codebase, $res->base)->rel($uri)->as_string;
	$pkg->{ppd_uri} = $uri;
	$pkg->{ppd_etag} = $res->header("ETag");
	$pkg->{ppd_lastmod} = $res->header("Last-Modified");
    }
    else {
	die "The PPD does not provide code to install for this platform";
    }
    # XXX follow dependencies with the "directory" of $pkg $uri as the
    # first repo to look for additional packages.  This only works for
    # package features.

    _install($pkg);
}

sub _install_repo {
    $ppm->repo_sync;
    _install(map $ppm->package_set_abs_ppd_uri($_), $ppm->packages_missing_for(@_));
}

sub _install {
    unless (@_) {
	print "Nothing to install\n";
	return;
    }

    $| = 1;
    my $verbose = 0;
    my $ua = web_ua();

    my $tmpdir = do { require File::Temp; File::Temp::tempdir("ppm-XXXXXX", TMPDIR => 1) };
    eval {
	# determine codebase_file
	for my $pkg (@_) {
	    my $name = $pkg->name_version;
	    my $codebase = $pkg->{codebase};
	    die "No codebase for $name" unless $codebase;
	    $codebase = URI->new_abs($codebase, $pkg->{ppd_uri});

	    if ($codebase =~ /\.(tgz|tar\.gz)$/) {
		$pkg->{codebase_type} = "tgz";
	    }
	    die "Don't know how to unpack $codebase" unless $pkg->{codebase_type};

	    if ($codebase->scheme eq 'file') {
		$pkg->{codebase_file} = $codebase->file;
		unless (-f $pkg->{codebase_file}) {
		    die "No file at $pkg->{codebase_file}";
		}
	    }
	    else {
		print "Downloading $name...";
		my $save = $pkg->{codebase_file} = "$tmpdir/$name.$pkg->{codebase_type}";
		#print "\n    $codebase ==> $save...";
		my $res = $ua->get($codebase, ":content_file" => $save);
		die $res->status_line unless $res->is_success;
		if (my $len = $res->content_length) {
		    my $save_len = -s $save;
		    if ($save_len != $len) {
			die "Aborted download ($len bytes expected, got $save_len).\n";
		    }
		}
		# XXX An MD5 checksum for the tarball would be a good thing
		print "done\n";
	    }
	}

	# unpack
	for my $pkg (@_) {
	    my $pname = $pkg->name_version;
	    print "Unpacking $pname...";
	    my $codebase_file = $pkg->{codebase_file};
	    if ($pkg->{codebase_type} eq "tgz") {
		require Archive::Tar;
		require ExtUtils::MakeMaker;
		require ActiveState::ModInfo;
		ppm_log("DEBUG", "Unpacking $codebase_file");
		my $tar = Archive::Tar->new($codebase_file, 1);
		for my $file ($tar->get_files) {
		    next unless $file->is_file;  # don't extract links and other crap
		    my $fname = $file->name;
		    next if $fname =~ m,/\.exists$,;       # don't think these are needed
		    next if $fname =~ m,/html/(bin|site/lib)/,;  # will always regenerate these
		    my $extract = $fname;
		    next unless $extract =~ s,^blib/,$pname/,;
		    $extract = "$tmpdir/$extract";
		    $tar->extract_file($fname, $extract)
			|| die "Can't extract to $extract";
		    if ($fname =~ /\.pm$/) {
			my $mod = $fname;
			if ($mod =~ s,^blib/(?:lib|arch)/,,) {
			    $mod = ActiveState::ModInfo::fname2mod($mod);
			    $mod .= "::" unless $mod =~ /::/;
			    $pkg->{provide}{$mod} = MM->parse_version($extract) || 0;
			}

		    }
		}
		$pkg->{blib} = "$tmpdir/$pname";
	    }
	    else {
		die "Don't know how to unpack $pkg->{codebase_type} files";
	    }
	    print "done\n";
	}

	# relocate
	if ($^O ne "MSWin32") {
	    require ActiveState::RelocateTree;
	    my $ppm_sponge = ActiveState::RelocateTree::spongedir('ppm');
	    my $prefix = do { require Config; $Config::Config{prefix} };
	    for my $pkg (@_) {
		print "Relocating ", $pkg->name_version, "...";
		ActiveState::RelocateTree::relocate (
		    to      => $pkg->{blib},
		    inplace => 1,
	            search  => $ppm_sponge,
	            replace => $prefix,
                    quiet   => 1,
		);
		print "done\n";
	    }
	}

	# XXX regenerate HTML

	# install
	print "Installing...";
	if (my $summary = $ppm->current_area->install(@_)) {
	    print "done\n";
	    for my $what (sort keys %$summary) {
		my $n = $summary->{$what} || 0;
		printf "%4d file%s %s\n", $n, ($n == 1 ? "" : "s"), $what;
	    }
	}
	else {
	    print "\n";
	    die $@;
	}

	# run install scripts
	for my $pkg (@_) {
	    _run_script($pkg, "install", $tmpdir);
	}
    };
    my $err = $@;
    rmtree($tmpdir, $verbose);
    die $err if $err;
}

sub _run_script {
    my($pkg, $kind, $tmpdir) = @_;
    my $script = $pkg->{script}{$kind};
    return unless $script;

    $tmpdir ||= do { require File::Temp; File::Temp::tempdir("ppm-XXXXXX", TMPDIR => 1, CLEANUP => 1) };

    my @commands;
    if (defined(my $uri = $script->{uri})) {
	print "Downloading ", $pkg->name_version, " $kind script...";
	my $res = web_ua()->get(URI->new_abs($uri, $pkg->{ppd_uri}));
	die $res->status_line unless $res->is_success;
	if (my $len = $res->content_length) {
	    my $save_len = length($res->content);
	    if ($save_len != $len) {
		die "Aborted download ($len bytes expected, got $save_len).\n";
	    }
	}
	if ($script->{exec}) {
	    my $file = "$tmpdir/${kind}_script";
	    open(my $fh, ">:utf8", $file) || die "Can't create $file: $!";
	    print $fh $res->decoded_content;
	    close($fh) || die "Can't write $file: $!";
	    chmod(0755, $file);
	    push(@commands, _expand_exec($script->{exec}, "${kind}_script"));
	}
	else {
	    push(@commands, grep length, split(/\n/, $res->decoded_content));
	}
	print "done\n";
    }
    else {
	if (my $exec = $script->{exec}) {
	    my $text = $script->{text};
	    $text =~ s/;;/\n/g;  # what ugliness

	    my $file = "$tmpdir/${kind}_script";
	    open(my $fh, ">", $file) || die "Can't create $file: $!";
	    print $fh $text;
	    close($fh) || die "Can't write $file: $!";
	    chmod(0755, $file);

	    push(@commands, _expand_exec($script->{exec}, "${kind}_script"));
	}
	else {
	    push(@commands, grep length, split(/;;/, $script->{text}));
	}
    }
    if (@commands) {
	require ActiveState::Run;
	require Cwd;
	my $old_cwd = Cwd::cwd();
	local $ENV{PPM_INSTROOT} = $ppm->current_area->prefix;
	local $ENV{PPM_INSTLIB} = $ppm->current_area->lib;
	local $ENV{PPM_INSTARCHLIB} = $ppm->current_area->archlib;
	local $ENV{PPM_VERSION} = do { require ActivePerl::PPM; $ActivePerl::PPM::VERSION };
	local $ENV{PPM_ACTION} = $kind;  # XXX 'upgrade'
	# local $ENV{PPM_PREV_VERSION} = ...;
	# local $ENV{PPM_NEW_VERSION} = ...;
	# local $ENV{PPM_INSTPACKLIST} = ....;
	local $ENV{PPM_PERL} = $^X;
	eval {
	    chdir $tmpdir;
	    print "Running ", $pkg->name_version, " $kind script...\n";
	    for my $cmd (@commands) {
		ActiveState::Run::run(ref($cmd) ? @$cmd : $cmd);
	    }
	};
	chdir($old_cwd) || die "Can't chdir back to '$old_cwd': $!";
	die if $@;
    }
}

sub _expand_exec {
    my $exec = shift;
    if (uc($exec) eq "SELF") {
	$exec = shift;
	$exec = "./$exec" if $^O ne "MSWin32";
    }
    elsif (uc($exec) eq "PPM_PERL" || $exec eq "perl") {
	$exec = $^X;
    }
    $exec = '@' . $exec;  # silence command echo
    return [$exec, @_];
}

sub do_remove {
    $USAGE = "remove <package> ...";
    usage() unless @ARGV;

    my $area = $ppm->current_area;
    my $removed_count = 0;
    for my $pkg (@ARGV) {
	my $o = $area->package($pkg);
	unless ($o) {
	    print "$pkg: not installed\n";
	    next;
	}
	eval {
	    _run_script($o, "uninstall");
	    print "$pkg: ";
	    $area->uninstall($pkg);
	};
	if ($@) {
	    $@ =~ s/ at .*// unless $ENV{ACTIVEPERL_PPM_DEBUG};
	    print $@;
	}
	else {
	    print "uninstalled\n";
	    $removed_count++;
	}
    }
    die "No packages uninstalled" unless $removed_count;
}

BEGIN {
    # aliases for PPM3 compatibility (mostly)
    *do_query = \&do_list;
    *do_update = \&do_upgrade;
    *do_uninstall = \&do_remove;
    *do_rep = \&do_repo;
}

__END__

=head1 NAME

ppm - Perl Package Manager, version 4

=head1 SYNOPSIS

Invoke the graphical shell (not implemented yet):

    ppm

Install, upgrade and remove packages from the current install area:

    ppm install [--force] <pkg>
    ppm install [--force] <module>
    ppm install [--force] <url>
    ppm install [--force] <file>.ppd
    ppm install [--force] <num>
    ppm upgrade <pkg>
    ppm upgrade <module>
    ppm remove <pkg>

Manage and search install areas:

    ppm area [--current <name>] [--sync] [--no-header]
    ppm list [--name] [--version] [--abstract] ...
    ppm list <area> [--name] [--version] [--abstract] ...
    ppm files <pkg>
    ppm verify [<pkg>]

Manage and search repositories:

    ppm repo list
    ppm repo sync [--force]
    ppm repo on <num>
    ppm repo off <num>
    ppm repo describe <num>
    ppm repo add <url> [<name>] [--username <user> [--password <passwd>]]
    ppm repo suggest
    ppm search <pattern>
    ppm describe <num>

Obtain version and copyright information about this program:

    ppm --version
    ppm version

=head1 DESCRIPTION

The C<ppm> program is the Package Manager for ActivePerl.  It
simplifies the task of locating, installing, upgrading and removing
Perl packages.

Invoking C<ppm> without arguments will bring up the grahical shell
(not implemented yet), but ppm can also be used as a command line tool
where the first argument provide the name of the sub-command to
invoke.  The following sub-commands are recognized (alphabetic order):

=over

=item B<ppm area>

Manage install areas.

=item B<ppm dump> [ I<what> ]

Internal debugging tool.

=item B<ppm describe> I<num>

Show all properties for the given package from the last search result.

=item B<ppm files> I<pkg>

Will list the full path name of the files belonging to the given
package, one line per file.

=item B<ppm help> [ I<subcommand> ]

Will print the documentation for PPM (this file).

=item B<ppm install> I<pkg>

=item B<ppm install> I<module>

=item B<ppm install> I<file>.ppd

=item B<ppm install> I<url>

=item B<ppm install> I<num>

Install a package and its dependencies.

=item B<ppm list> [ I<area> ] --I<field> ...

List the packages installed.  If I<area> is not provided list the
content of the current install area.

=item B<ppm query>

Alias for B<ppm list>.  Provided for PPM version 3 compatiblity.

=item B<ppm remove> I<pkg> ...

Will uninstall the given packages from the current install area.

=item B<ppm rep> ...

Alias for B<ppm repo>.  Provided for PPM version 3 compatiblity.

=item B<ppm repo>

Manage repositories.

=item B<ppm search> I<pattern>

Search for packages matching I<pattern> in all enabled repositories.

=item B<ppm uninstall> ...

Alias for B<ppm remove>.

=item B<ppm update> ...

Alias for B<ppm upgrade>.

=item B<ppm upgrade> I<pkg>

=item B<ppm upgrade> I<module>

Will look for upgrades for the given package or module from the
current enabled repositories and install it.

=item B<ppm verify> [ I<pkg> ]

Will check that the installed files are still present and unmodified.
If the name of a package is given only verify that package.

=item B<ppm version>

Will print the current version of PPM and a copyright notice.

=back

=head1 FILES

The following lists files and directories that PPM uses and creates:

=over

=item F<$HOME/.ActivePerl/>

Directory where PPM keeps its state.  On Windows this directory is
F<$APPDATA/ActiveState/ActivePerl/>.  Architecture or version specific
directories can be created if you need to manage multiple perl
installation from the same home area.

=item F<$HOME/.ActivePerl/lib/>

If this directory is present the PPM will have an install area called
"home" that you can install packages into.  Useful if you use an
ActivePerl installation that you dont have permissions to modify.

=item F<$HOME/.ActivePerl/ppm.db>

SQLite database where PPM keep its configuration and cache meta
information about the content of the enabled repositories.

=item F<$HOME/ppm4.log>

Log file created to record actions that ppm take.
On Windows this log goes to F<$TEMPDIR/ppm4.log>.

=item F<$PREFIX/etc/ppm-area.db>

SQLite database where PPM keep track of packages installed in the install area
under C<$PREFIX>.

=item F<$TEMPDIR/ppm-XXXXXX/>

Temporary directories used during install.  Packages to be installed
are unpacked here.

=item F<*.ppd>

The meta information about a single package is represented in XML by a
PPD file.  See L<ActivePerl::PPM::PPD> for additional information.

=item F<package.xml>

Meta information about whole repositories are found in F<package.xml>
files.  When a repository is added then ppm will look for this file
and if present monitor it too keep itself in sync with the state of
the repository.

=item F<package.lst>

Same as F<package.xml> but PPM 3 compatible.  PPM will use this file
if F<package.xml> is not available.

=back

=head1 ENVIRONMENT

The following environment variables affect how PPM behaves:

=over

=item C<ACTIVEPERL_PPM_DEBUG>

If set to a TRUE value make ppm print more internal diagnostics.

=item C<ACTIVEPERL_PPM_HOME>

If set use this directory instead of F<~/.ActivePerl/> to store
configuration information for PPM.

=item C<ACTIVEPERL_PPM_LOG_CONS>

If set to a TRUE value make ppm print any log output to the console as well.

=item C<DBI_TRACE>

ppm use L<DBI> to access the internal SQLite databases and setting
DBI_TRACE allow you to see what queries are performed.  Output goes to
STDERR.  See L<DBI> for further details.

=back

=head1 WHAT'S NEW IN VERSION 4

PPM version 4 is a complete rewrite.  The main changes since ppm version 3 are:

=over

=item *

The command line shell has been replaced with a graphical shell (not implemented yet, but will be in Beta 2).

=item *

PPM can now manage different installation areas.

=item *

No more precious packages.  PPM can upgrade itself as well other bundled and core modules.

=item *

Installation of packages and its dependencies happens as an atomic transaction.

=item *

PPM tracks what files it has installed and can notice if files has
been modified or deleted.  The command 'ppm verify' will report on mismatches.

=item *

State kept in local SQLite databases.  All repository state is kept
local which makes search much faster.

=item *

PPM will pick up and manage packages installed by other means;
manually or by using the CPAN shell.

=item *

No more SOAP

=item *

Underlying modules moved to the C<ActivePerl::PPM::> namespace.

=back

=head1 SEE ALSO

L<activeperl>

L<http://search.cpan.org/dist/PPM-Repositories/>

=head1 COPYRIGHT

Copyright (C) 2006 ActiveState Software Inc.  All rights reserved.

=cut
