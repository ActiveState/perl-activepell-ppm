#!/usr/bin/perl -w

use strict;
use ActivePerl::PPM::Client;
use ActivePerl::PPM::Web qw(web_ua);
use ActivePerl::PPM::Logger qw(ppm_log);
use File::Path qw(mkpath rmtree);

(my $PROGNAME = $0) =~ s,.*[\\/],,;

my $CMD = shift || gui();
$CMD = "version" if $CMD eq "--version";

my $do_cmd = "do_$CMD";
usage("Unrecognized ppm command '$CMD'") unless defined &$do_cmd;

my $ppm = ActivePerl::PPM::Client->new;

eval {
    no strict 'refs';
    ppm_log("INFO", "$PROGNAME $CMD" . (@ARGV ? " @ARGV" : ""));
    &$do_cmd;
};
if ($@) {
    ppm_log("ERR", "$PROGNAME $CMD: $@");
    #$@ =~ s/ at .*//;
    print STDERR "$PROGNAME $CMD failed: $@";
    exit 1;
}
else {
    exit;
}

my $USAGE;
sub usage {
    my $msg = shift;
    if ($msg) {
	$msg .= "\n" unless $msg =~ /\n$/;
	print STDERR $msg;
    }
    $USAGE ||= "<cmd> args...";
    print STDERR "Usage: $PROGNAME $USAGE\n";
    exit 1;
}

sub gui {
    die "GUI NYI";
}

sub do_dump {
    require Data::Dump;
    push(@ARGV, "client") unless @ARGV;
    for my $what (@ARGV) {
	if ($what eq "client") {
	    Data::Dump::dump($ppm);
	}
	elsif (grep $_ eq $what,$ppm->idirs) {
	    Data::Dump::dump($ppm->idirs($what));
	}
	elsif (grep $_ eq $what, $ppm->repos) {
	    Data::Dump::dump($ppm->repo($what));
	}
	elsif (my $pkg = $ppm->current_idirs->package($what)) {
	    Data::Dump::dump($pkg);
	}
	else {
	    warn "No idirs/repo/package called $what\n";
	}
    }
}

sub do_version {
    if (@ARGV) {
	$USAGE = "version";
	usage("The $CMD command does not take arguments.");
    }
    require ActivePerl::PPM;
    print "ppm $ActivePerl::PPM::VERSION\n";
    print "Copyright (C) 2006 ActiveState Software Inc.  All rights reserved.\n";
}

sub do_idirs {
    my $current = $ppm->current_idirs_name;
    my $show_header = 1;
    if (@ARGV) {
	my $new_current;
	my $sync;
	$USAGE = "idirs [--current [<name>]] [--sync] [--no-header]";
	require Getopt::Long;
	Getopt::Long::GetOptions(
           'current:s' => \$new_current,
	   'sync' => \$sync,
           'header!' => \$show_header,
        ) || usage();
	usage() if @ARGV;
	if (defined $new_current) {
	    $ppm->current_idirs_name($new_current) if length($new_current);
	    $ppm->current_idirs->sync_db if $sync;
	    if (length($new_current)) {
		print "Current idir is now $new_current.\n";
	    }
	    else {
		print "$current\n";
	    }
	    return;
	}
	$ppm->current_idirs->sync_db if $sync;
    }
    if ($show_header) {
	print "cur name   pkg# lib\n";
	print "--- ------ ---- ------------------------------------\n";
    }
    for my $idir ($ppm->idirs) {
	my $o = $ppm->idirs($idir);
	printf "%3s %-6s %4d %s\n",
	    ($current eq $idir ? "->" : ""),
	    $idir,
	    scalar($o->packages),
	    $o->lib;
    }
}

sub do_list {
    my %opt;
    if (@ARGV) {
	$USAGE = "list [--name] [--version] [--abstract] [--author]";
	require Getopt::Long;
	Getopt::Long::GetOptions(\%opt,
           'id',
           'name',
           'version',
           'abstract',
           'author',
	   'files',
           'size',
        ) || usage();
	usage() if @ARGV;
    }
    else {
	$opt{version}++;
	$opt{abstract}++;
	$opt{files}++;
	$opt{size}++;
    }
    $opt{name}++;

    my $idir = $ppm->current_idirs;
    if (keys %opt == 1) {
	# just list the names
	for my $pkg ($idir->packages) {
	    print "$pkg\n";
	}
    }
    else {
	my @fields;
	push(@fields, "name");
	push(@fields, "version") if $opt{version};
	push(@fields, "abstract") if $opt{abstract};
	push(@fields, "author") if $opt{author};
	require ActiveState::Table;
	my $tab = ActiveState::Table->new;
	$tab->add_field($_) for @fields;
	$tab->add_field("files") if $opt{files};
	$tab->add_field("size") if $opt{size};
	for my $pkg ($idir->packages(@fields)) {
	    my %row = map {$_ => shift(@$pkg)} @fields;
	    if ($opt{files} || $opt{size}) {
		my @files = $idir->package_files($row{name});
		$row{files} = @files if $opt{files};
		$row{size} = do {
		    require ActiveState::DiskUsage;
		    require ActiveState::Bytes;
		    my $size = 0;
		    $size += ActiveState::DiskUsage::du($_) for @files;
		    $size = ActiveState::Bytes::bytes_format($size);
		} if $opt{size};
	    }
	    $tab->add_row(\%row);
	}
	print $tab->as_box(null => "", show_trailer => 0);
    }
}

sub do_files {
    $USAGE = "files <pkg>";
    usage() unless @ARGV == 1;
    print "$_\n" for $ppm->current_idirs->package_files($ARGV[0]);
}

sub do_verify {
    my %opt;
    if (@ARGV) {
	$USAGE = "verify [--verbose] [<package>]";
	require Getopt::Long;
	Getopt::Long::GetOptions(\%opt,
           'verbose',
        ) || usage();
	$opt{package} = shift(@ARGV) if @ARGV;
	usage() if @ARGV;
    }
    my $idir = $ppm->current_idirs;
    my %status = $idir->verify(%opt);
    for my $v (qw(verified missing modified)) {
	next if $v ne "verified" && !$status{$v};
	my $s = $status{$v} == 1 ? "" : "s";
	print "$status{$v} file$s $v.\n";
    }
}

sub do_repo {
    my $cmd = shift(@ARGV) || "list";
    if ($cmd eq "list") {
	$USAGE = "repo list";
	usage() if @ARGV;
	for my $repo_id ($ppm->repos) {
	    my $repo = $ppm->repo($repo_id);
	    my $status = $repo->{enabled} ? "" : "(OFF) ";
	    print "[$repo_id] $status$repo->{name} <$repo->{packlist_uri}>\n";
	}
    }
    elsif ($cmd eq "sync") {
	$USAGE = "repo sync";
	usage() if @ARGV;
	$ppm->repo_sync;
    }
    elsif ($cmd eq "on" || $cmd eq "off" || $cmd eq "delete" || $cmd eq "describe") {
	$USAGE = "repo $cmd <num>";
	usage() if @ARGV != 1;
	my $repo = $ppm->repo($ARGV[0]);
	die "No such repo; 'ppm repo list' will print what's available" unless $repo;
	if ($cmd eq "delete") {
	    $ppm->repo_delete($ARGV[0]);
	}
	elsif ($cmd eq "describe") {
	    require ActiveState::Duration;
	    print "Id: $repo->{id}\n";
	    print "Name: $repo->{name}\n";
	    print "URL: $repo->{packlist_uri}\n";
	    print "Prio: $repo->{prio}\n";
	    print "Enabled: ", ($repo->{enabled} ? "yes" : "no"), "\n";
	    if (my $fresh_until = $repo->{packlist_fresh_until}) {
		my $refresh_in = $fresh_until - time;
		if ($refresh_in >= 0) {
		    print "Refresh-In: ", ActiveState::Duration::dur_format_eng($refresh_in), "\n";
		}
		else {
		    print "Refresh-In: overdue\n";
		}
	    }
	    if (my $lastmod = $repo->{packlist_lastmod}) {
		require HTTP::Date;
		print "Last-Modified: ", ActiveState::Duration::ago_eng(time - HTTP::Date::str2time($lastmod)), "\n";
	    }
	}
	else {
	    $ppm->repo_enable($ARGV[0], $cmd eq "on");
	}
    }
    elsif ($cmd eq "add") {
	$USAGE = "repo add <url> [<name>]";
	my $url = shift(@ARGV) || usage();
	my $name;
	if (@ARGV) {
	    $name = shift(@ARGV);
	    if ($url !~ /^[a-z][+\w]+:/ && $name =~ /^[a-z][+\w]+:/) {
		# ppm3 had the arguments reversed, so try that
		($url, $name) = ($name, $url);
	    }
	}
	else {
	    $name = eval { URI->new($url)->host } || $url;
	}
	unless ($url =~ /^[a-z][+\w]+:/) {
	    if (-d $url) {
		require URI::file;
		$url = URI::file->new_abs($url);
	    }
	    else {
		die "The repository URL must be absolute or a local directory";
	    }
	}
	my $id = $ppm->repo_add(name => $name, packlist_uri => $url);
	print "Repo $id added.\n";
    }
    else {
	$USAGE = "repo <cmd> <args>";
	usage("The repo command '$cmd' isn't recognized; try one of list, describe, add, delete, on, off");
    }
}

sub do_search {
    $USAGE = "search <pattern>";
    usage() unless @ARGV == 1;
    my $pattern = shift(@ARGV);
    my @res = $ppm->search($pattern);
    if (@res) {
	print "$_\n" for @res;
    }
    else {
	print "no packages found\n";
    }
}

sub do_install {
    $USAGE = "install [--force] <module> | <url> | <file>";
    my $force;
    require Getopt::Long;
    Getopt::Long::GetOptions(
        force => \$force,
     ) || usage();
    usage() unless @ARGV == 1;
    my $feature = shift(@ARGV);
    if ($feature =~ m,^[a-z][+\w]+:[^:],) {
	# looks like an absolute URL
	_install_uri($feature);
    }
    elsif ($feature =~ /\.ppd$/) {
	require URI::file;
	_install_uri(URI::file->new_abs($feature));
    }
    else {
	# seach for feature in repos
	_install($ppm->packages_missing_for($feature, 0, force => $force));
    }
}

sub do_upgrade {
    $USAGE = "upgrade <module>";
    usage() unless @ARGV == 1;
    my $feature = shift(@ARGV);
    _install($ppm->packages_missing_for($feature, undef));
}

sub _install_uri {
    my $uri = shift;
    my $res = web_ua->get($uri);
    unless ($res->is_success) {
	die $res->status_line;
    }
    require ActivePerl::PPM::PPD;
    my $cref = $res->content_ref;
    my $pkg = ($$cref =~ /</ && $$cref =~ />/) ? ActivePerl::PPM::Package->new_ppd($$cref) : undef;
    unless ($pkg) {
	die "No PPD found at $uri";
    }
    if (my $codebase = $pkg->{codebase}) {
	# make it absolute
	$pkg->{codebase} = URI->new_abs($codebase, $res->base)->as_string;
    }
    else {
	die "The PPD does not provide code to install for this platform";
    }
    # XXX follow dependencies with the "directory" of $pkg $uri as the
    # first repo to look for additional packages.  This only works for
    # package features.

    _install($pkg);
}

sub _install {
    unless (@_) {
	print "Nothing to install\n";
	return;
    }

    $| = 1;
    my $verbose = 0;
    my $ua = web_ua();

    my $tmpdir = "/tmp/ppm-$$";
    mkpath($tmpdir, $verbose) || die "Can't mkpath('$tmpdir'): $!";
    eval {
	for my $pkg (@_) {
	    my $name = $pkg->name_version;
	    my $codebase = $pkg->codebase;
	    die "No codebase for $name" unless $codebase;

	    if ($codebase =~ /\.(tgz|tar\.gz)$/) {
		$pkg->{codebase_type} = "tgz";
	    }
	    die "Don't know how to unpack $codebase" unless $pkg->{codebase_type};

	    if ($codebase =~ /^file:/) {
		$pkg->{codebase_file} = URI->new($codebase)->file;
		unless (-f $pkg->{codebase_file}) {
		    die "No file at $pkg->{codebase_file}";
		}
	    }
	    else {
		print "Downloading $name...";
		my $save = $pkg->{codebase_file} = "$tmpdir/$name.$pkg->{codebase_type}";
		#print "\n    $codebase ==> $save...";
		my $res = $ua->get($codebase, ":content_file" => $save);
		die $res->status_line unless $res->is_success;
		if (my $len = $res->content_length) {
		    my $save_len = -s $save;
		    if ($save_len != $len) {
			die "Aborted download ($len bytes expected, got $save_len).\n";
		    }
		}
		# XXX An MD5 checksum for the tarball would be a good thing
		print "done\n";
	    }
	}

	for my $pkg (@_) {
	    my $pname = $pkg->name_version;
	    print "Unpacking $pname...";
	    my $codebase_file = $pkg->{codebase_file};
	    if ($pkg->{codebase_type} eq "tgz") {
		require Archive::Tar;
		require ExtUtils::MakeMaker;
		require ActiveState::ModInfo;
		ppm_log("DEBUG", "Unpacking $codebase_file");
		my $tar = Archive::Tar->new($codebase_file, 1);
		for my $file ($tar->get_files) {
		    next unless $file->is_file;  # don't extract links and other crap
		    my $fname = $file->name;
		    next if $fname =~ m,/\.exists$,;       # don't think these are needed
		    next if $fname =~ m,/html/(bin|site/lib)/,;  # will always regenerate these
		    my $extract = $fname;
		    next unless $extract =~ s,^blib/,$pname/,;
		    $extract = "$tmpdir/$extract";
		    $tar->extract_file($fname, $extract)
			|| die "Can't extract to $extract";
		    if ($fname =~ /\.pm$/) {
			my $mod = $fname;
			if ($mod =~ s,^blib/(?:lib|arch)/,,) {
			    $mod = ActiveState::ModInfo::fname2mod($mod);
			    $mod .= "::" unless $mod =~ /::/;
			    $pkg->{provide}{$mod} = MM->parse_version($extract) || 0;
			}

		    }
		}
		$pkg->{blib} = "$tmpdir/$pname";
	    }
	    else {
		die "Don't know how to unpack $pkg->{codebase_type} files";
	    }
	    print "done\n";
	}

	# XXX install scripts
	# XXX regenerate HTML

	# do the install
	print "Installing...";
	if (my $summary = $ppm->current_idirs->install(@_)) {
	    print "done\n";
	    for my $what (sort keys %$summary) {
		my $n = $summary->{$what} || 0;
		printf "%4d file%s %s\n", $n, ($n == 1 ? "" : "s"), $what;
	    }
	    # XXX post install scripts
	}
	else {
	    print "\n";
	    die;
	}

    };
    my $err = $@;
    rmtree($tmpdir, $verbose);
    die $err if $err;
}

sub do_remove {
    $USAGE = "remove <package>";
    usage() unless @ARGV == 1;
    $ppm->current_idirs->uninstall($ARGV[0]);
}

BEGIN {
    # aliases for PPM3 compatibility (mostly)
    *do_query = \&do_list;
    *do_update = \&do_upgrade;
    *do_uninstall = \&do_remove;
    *do_rep = \&do_repo;
}
