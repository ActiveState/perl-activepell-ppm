#!/usr/bin/env perl

use strict;
use warnings;

# TODO:
#  - relativeize all HREFs (REPOSITORYSUMMARY BASE)
#  - merge PPDs
#  - download HREFs (create standalone directory)

use Getopt::Long qw(GetOptions);
use LWP 5.820;
use URI;
use URI::file;

GetOptions(\my %opt,
    'base=s',
) || usage();
usage() unless @ARGV;

my $base = $opt{base} ? URI->new($opt{base}) : URI::file->cwd;

my $ua = LWP::UserAgent->new(
    keep_alive => 1,
    show_progress => 1,
);

#print "BASE: $base\n";

my @ppd;
while (@ARGV) {
    my $url = shift;
    my $res = $ua->get(URI->new_abs($url, $base));
    if (my $len = $res->content_length) {
	if (length($res->content) != $len) {
	    warn "incomplete download, skipping";
	    next;
	}
    }
    next unless $res->is_success;
    if ($res->content_type =~ m,^application/(x-)?gzip$,) {
        # tweak response so that 'decoded_content' will decode it
        $res->content_type("application/octet-stream");
        $res->push_header("Content-Encoding", "gzip");
    }
    $res->decode;
    my $cref = $res->content_ref;

    if ($res->content_is_html) {
	my $base = $res->base;
	my @href;
	require HTML::Parser;
	my $p = HTML::Parser->new(
	    report_tags => [qw(a)],
	    start_h => [sub {
		my $href = shift->{href} || return;
		push(@href, URI->new_abs($href, $base)) if $href =~ /\.ppd$/;
	    }, "attr"],
	);
	$p->parse($$cref)->eof;
	if (@href) {
	    warn "Following " . scalar(@href) . " PPD links";
	    unshift(@ARGV, @href);
	}
	else {
	    warn "HTML resource without PPD links, skipping";
	}
	next;
    }

    unless ($$cref =~ /<SOFTPKG\s/) {
	warn "contains no PPDs, skipping";
	next;
    }
    my $arch;
    my $base = $res->base;
    if ($$cref =~ /<REPOSITORYSUMMARY(\s[^>]*)>/s) {
	my $attr = $1;
	while ($attr =~ /\G\s+(\w+)\s*=\s*"([^"]*)"/g) {
	    if ($1 eq "ARCHITECTURE") {
		$arch = $2;
	    }
	    elsif ($1 eq "BASE") {
		$base = URI->new($2);
	    }
	}
    }
    my @pkgs = ($$cref =~ /(<SOFTPKG\s.*?<\/SOFTPKG\s*>)/gs);
    splice(@pkgs, 5) if @pkgs > 5;  # XXX smaller size during debug
    for (@pkgs) {
	$_ = PPD->new($_, $base, $arch);
	$_->merge_arch;
	$_->absolutize;
    }
    push(@ppd, @pkgs);
}

#use Data::Dump; dd @ppd;

print qq(<?xml version="1.0" encoding="UTF-8"?>\n);
print "<REPOSITORYSUMMARY>\n";
for (@ppd) {
    print $_->as_xml, "\n";
}
print "</REPOSITORYSUMMARY>\n";

BEGIN {
    package PPD;

    sub new {
	my($class, $xml, $base, $arch) = @_;
	bless [$xml, $base, $arch], $class;
    }

    sub arch {
	my $self = shift;
	$self->[2] || "noarch";
    }

    sub indent {
	my $self = shift;
	return $1 if $self->[0] =~ /^(\s+)<AUTHOR/m;
	return "";
    }

    sub absolutize {
	my $self = shift;
	my $base = $self->[1];
	$self->[0] =~ s{(\sHREF\s*=\s*)"([^"]*)"}{
            my $href = URI->new_abs($2, $base);
            qq($1"$href");
        }ge;
    }

    sub merge_arch {
	my $self = shift;
        my $arch = $self->arch;
	if ($arch ne "noarch" && $self->[0] !~ /<ARCHITECTURE/) {
	    $self->push_elem(qq(<ARCHITECTURE NAME="$arch"/>));
	}
    }

    sub push_elem {
	my($self, $xml) = @_;
	if (my $indent = $self->indent) {
	    $xml =~ s/^/$indent/g;
	}
	$self->[0] =~ s,(</SOFTPKG\s*>\z),$xml\n$1,;
    }

    sub as_xml {
	my $self = shift;
	return $self->[0];
    }
}

sub usage {
    (my $progname = $0) =~ s,.*/,,;
    die "Usage: $progname [options] URL...\n";
}

__END__

=head1 NAME

ppm-repo-combine - Generate combined package.xml file

=head1 SYNOPSIS

B<ppm-repo-combine> [ B<--base> I<URL> ] I<URL>...

=head1 DESCRIPTION

The B<ppm-repo-combine> script takes a list of URLs to F<package.xml>
or F<*.ppd> files on the command line.  The files are fetched, links
rewritten and all the PPDs combined into a single F<package.xml> file
that is printed on STDOUT.

Typical usage might be something like:

  ppm-repo-combine $(find . -name \*.ppd) >package.xml

For each URL that reference an HTML document, all the links to F<.ppd>
files will be followed and incorporated in the output file.  This is
useful as it allows us to create F<package.xml> files from web server
generated directory index pages.  Links to C<package.xml> files are
ignored.

Local directories are also treated the same way, that is all F<*.ppd>
files contained in them are incorporated (but F<*.ppd> files in
sub-directories are not).

The following options are recognized:

=over

=item B<--base> I<URL>

Set the base URL used for resolving relative URLs.  It defaults to the
C<file:> URL denoting the current directory, which means that local
relative file name are interpreted in the obvious way.

=back

=head1 SEE ALSO

L<ppm>, L<ActivePerl::PPM::PPD>
